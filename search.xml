<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>GitHub-Pages自定义域名原理</title>
    <url>/2021/04/07/Github-Pages%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>[toc]</p>
<h2 id="github-pages-用法">GitHub Pages 用法</h2>
<p>GitHub Pages <a href="https://docs.github.com/en/pages/configuring-a-custom-domain-for-your-github-pages-site">提供了自定义域名的功能</a>，可以通过如下操作来配置：</p>
<ol type="1">
<li><p>在相应repo的设置里找到 Custom Domain 进行设置。 <img src="/2021/04/07/Github-Pages%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D%E5%8E%9F%E7%90%86/image-20210407164637971.png" alt="image-20210407164637971" style="zoom:67%;"></p></li>
<li><p>在自己的DNS提供商处设置CNAME记录，例如把 <code>null.sakuya.world</code> 指向 <code>rheinhauss.github.io</code> 。</p></li>
</ol>
<p>更详细的信息请参阅 GitHub 相关文档。</p>
<h2 id="原理">原理</h2>
<p>自然我们要研究一下是怎么实现的（看上去就是普普通通的 CNAME ）。</p>
<p>假设两种情况：</p>
<ol type="1">
<li><p>只在DNS提供商那里设置CNAME，如图 <img src="/2021/04/07/Github-Pages%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D%E5%8E%9F%E7%90%86/image-20210407165622647.png" alt="image-20210407165622647"></p>
<p>此时访问 <code>test.null.sakuya.world</code> 返回的是GitHub的404页面 <img src="/2021/04/07/Github-Pages%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D%E5%8E%9F%E7%90%86/image-20210407165907442.png" alt="image-20210407165907442" style="zoom:67%;"></p></li>
<li><p>只在GitHub的repo设置里配置Custom Domain，访问该自定义网址，有 <img src="/2021/04/07/Github-Pages%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D%E5%8E%9F%E7%90%86/image-20210407170201369.png" alt="image-20210407170201369" style="zoom:80%;"></p></li>
</ol>
<p>这是为什么呢？于是尝试 <code>dig</code> 和抓包来分析发生了什么。</p>
<p>我使用的是BIND工具包里的dig。</p>
<p>执行 <code>dig +trace null.sakuya.world</code> ，得到结果</p>
<figure class="highlight tap"><table><tr><td class="code"><pre><span class="line">; &lt;&lt;&gt;&gt; DiG 9.16.13 &lt;&lt;&gt;&gt; +trace null.sakuya.world</span><br><span class="line">;; global options: +cmd</span><br><span class="line">.                      <span class="number"> 437031 </span> IN      NS      f.root-servers.net.</span><br><span class="line">.                      <span class="number"> 437031 </span> IN      NS      l.root-servers.net.</span><br><span class="line">.                      <span class="number"> 437031 </span> IN      NS      k.root-servers.net.</span><br><span class="line">.                      <span class="number"> 437031 </span> IN      NS      e.root-servers.net.</span><br><span class="line">.                      <span class="number"> 437031 </span> IN      NS      b.root-servers.net.</span><br><span class="line">.                      <span class="number"> 437031 </span> IN      NS      m.root-servers.net.</span><br><span class="line">.                      <span class="number"> 437031 </span> IN      NS      d.root-servers.net.</span><br><span class="line">.                      <span class="number"> 437031 </span> IN      NS      c.root-servers.net.</span><br><span class="line">.                      <span class="number"> 437031 </span> IN      NS      j.root-servers.net.</span><br><span class="line">.                      <span class="number"> 437031 </span> IN      NS      g.root-servers.net.</span><br><span class="line">.                      <span class="number"> 437031 </span> IN      NS      a.root-servers.net.</span><br><span class="line">.                      <span class="number"> 437031 </span> IN      NS      h.root-servers.net.</span><br><span class="line">.                      <span class="number"> 437031 </span> IN      NS      i.root-servers.net.</span><br><span class="line">;; Received<span class="number"> 267 </span>bytes from 10.0.0.13<span class="comment">#53(10.0.0.13) in 5 ms</span></span><br><span class="line">// 获取根服务器</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">world.                 <span class="number"> 172800 </span> IN      NS      demand.gamma.aridns.net.au.</span><br><span class="line">world.                 <span class="number"> 172800 </span> IN      NS      demand.alpha.aridns.net.au.</span><br><span class="line">world.                 <span class="number"> 172800 </span> IN      NS      demand.delta.aridns.net.au.</span><br><span class="line">world.                 <span class="number"> 172800 </span> IN      NS      demand.beta.aridns.net.au.</span><br><span class="line">world.                 <span class="number"> 86400 </span>  IN      DS     <span class="number"> 32434 </span>8<span class="number"> 1 </span>1596E70AD9CA4E41EC20414EC7DE740257786677</span><br><span class="line">world.                 <span class="number"> 86400 </span>  IN      DS     <span class="number"> 32434 </span>8<span class="number"> 2 </span>18643A414DCC7EE02580E7A21793A0F63F5393C400DE9CA004465755 BF7CFF05</span><br><span class="line">world.                 <span class="number"> 86400 </span>  IN      RRSIG   DS<span class="number"> 8 </span>1<span class="number"> 86400 </span>20210419170000<span class="number"> 20210406160000 </span>14631 . ZK3ZM0VBTHPGMhdmX4W9LW/2e+TrC/afrnCzCc14X9U+h/OILV28EX1L dRY1zqGCZZpvnb5qsiaYIiDDdOurhgESTDwOO7XQGs8Hx9XFxc9dEFV+ FF0Ynx4WiZV+pZMxCf4L5H1aUaOWPGyuZHxTGyUdYECnrbivivzfjUD2 9VL3eUeLEOONPV7H83shzPybhxh9NjDCSYfljYgRzt48TrlUUAJE2z39 wtWHEyOraCk4e9XobaFmwNTuUFvqTFuf/+4zDGLkNnxpNaQofn5dFM9t EMI7jG0MqZw6nKMy5jv8BR7Y7+of4ZXJhCK9Dic5IVlZ62K+j/z5Urgr SUNG/A==</span><br><span class="line">;; Received<span class="number"> 741 </span>bytes from 2001:7fe::53<span class="comment">#53(i.root-servers.net) in 31 ms</span></span><br><span class="line">// 从根服务器获取顶级域名记录</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sakuya.world.          <span class="number"> 86400 </span>  IN      NS      ns3.he.net.</span><br><span class="line">sakuya.world.          <span class="number"> 86400 </span>  IN      NS      ns5.he.net.</span><br><span class="line">sakuya.world.          <span class="number"> 86400 </span>  IN      NS      ns2.he.net.</span><br><span class="line">sakuya.world.          <span class="number"> 86400 </span>  IN      NS      ns4.he.net.</span><br><span class="line">domi2ilach7iekt0e4kfuv9gfj62vr0u.world.<span class="number"> 86400 </span>IN NSEC3<span class="number"> 1 </span>1<span class="number"> 1 </span>7CD0CF42 DOUN8CS85QFN98IORLO2HVUF2L5F696S NS SOA RRSIG DNSKEY NSEC3PARAM</span><br><span class="line">domi2ilach7iekt0e4kfuv9gfj62vr0u.world.<span class="number"> 86400 </span>IN RRSIG NSEC3<span class="number"> 8 </span>2<span class="number"> 86400 </span>20210507082438<span class="number"> 20210407072438 </span>19704 world. Zhf5SHBslCcz9c1ywuoqo8jLKnxtHU2zgpb7SpHsES3IrKLLCa2cxNDN 2DGh2Dcdjx9nR+j0yGI5DSawLE9QTEZC0TKC/cn4BWXPbkyHEaA6KpDm cTPuKRdWvRD99zG8AJIF+MhC4mpZIPDeaVVK5udtwqn2rA+B6tc7LNbk thSpYeFg6NAbuie7p+O0UUga+6EVb+nesp0lbiWejOdEXw==</span><br><span class="line">5lp930j1svf536kt4a909i566itlnoa8.world.<span class="number"> 86400 </span>IN NSEC3<span class="number"> 1 </span>1<span class="number"> 1 </span>7CD0CF42 5MEH8F935EFLDLTPKHCTE9LRBA958KVS NS DS RRSIG</span><br><span class="line">5lp930j1svf536kt4a909i566itlnoa8.world.<span class="number"> 86400 </span>IN RRSIG NSEC3<span class="number"> 8 </span>2<span class="number"> 86400 </span>20210506165014<span class="number"> 20210406162719 </span>19704 world. m1rvU0mRNT7PdV80wp1F8oW3mYl0LUYyZxxNYPBtHjhvy1//2SATsyzD Z+/LUVBbfiWW6cJP4Ey8bhOwExB+faZF3qbKL7/bUpFe5Sy/BZXJiFKw DgFeYAYTPY9WtTWNpxnEvqm6g0N83yLj7EpUuOex87uBkrJZ+cIR4a0K RklrxgZRA2NuHfWvdAdTY/ach21k8kkba/Ao0dJjmn2ZPQ==</span><br><span class="line">;; Received<span class="number"> 690 </span>bytes from 2001:dcd:1::7<span class="comment">#53(demand.alpha.aridns.net.au) in 29 ms</span></span><br><span class="line">//从上条获取的 demand.xxxx.aridns.net.au 获取二级域名记录</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">null.sakuya.world.     <span class="number"> 86400 </span>  IN      CNAME   rheinhauss.github.io.</span><br><span class="line">;; Received<span class="number"> 80 </span>bytes from 2001:470:200::2<span class="comment">#53(ns2.he.net) in 72 ms</span></span><br></pre></td></tr></table></figure>
<p>最终是CNAME到 <code>rheinhauss.github.io</code> ，于是继续 <code>dig +trace rheinhauss.github.io</code> ，得到</p>
<figure class="highlight tap"><table><tr><td class="code"><pre><span class="line">; &lt;&lt;&gt;&gt; DiG 9.16.13 &lt;&lt;&gt;&gt; +trace rheinhauss.github.io</span><br><span class="line">;; global options: +cmd</span><br><span class="line">.                      <span class="number"> 436307 </span> IN      NS      i.root-servers.net.</span><br><span class="line">.                      <span class="number"> 436307 </span> IN      NS      d.root-servers.net.</span><br><span class="line">.                      <span class="number"> 436307 </span> IN      NS      g.root-servers.net.</span><br><span class="line">.                      <span class="number"> 436307 </span> IN      NS      e.root-servers.net.</span><br><span class="line">.                      <span class="number"> 436307 </span> IN      NS      k.root-servers.net.</span><br><span class="line">.                      <span class="number"> 436307 </span> IN      NS      l.root-servers.net.</span><br><span class="line">.                      <span class="number"> 436307 </span> IN      NS      a.root-servers.net.</span><br><span class="line">.                      <span class="number"> 436307 </span> IN      NS      b.root-servers.net.</span><br><span class="line">.                      <span class="number"> 436307 </span> IN      NS      h.root-servers.net.</span><br><span class="line">.                      <span class="number"> 436307 </span> IN      NS      c.root-servers.net.</span><br><span class="line">.                      <span class="number"> 436307 </span> IN      NS      f.root-servers.net.</span><br><span class="line">.                      <span class="number"> 436307 </span> IN      NS      m.root-servers.net.</span><br><span class="line">.                      <span class="number"> 436307 </span> IN      NS      j.root-servers.net.</span><br><span class="line">;; Received<span class="number"> 267 </span>bytes from 10.0.0.13<span class="comment">#53(10.0.0.13) in 6 ms</span></span><br><span class="line"></span><br><span class="line">io.                    <span class="number"> 172800 </span> IN      NS      a2.nic.io.</span><br><span class="line">io.                    <span class="number"> 172800 </span> IN      NS      b0.nic.io.</span><br><span class="line">io.                    <span class="number"> 172800 </span> IN      NS      c0.nic.io.</span><br><span class="line">io.                    <span class="number"> 172800 </span> IN      NS      a0.nic.io.</span><br><span class="line">io.                    <span class="number"> 86400 </span>  IN      DS     <span class="number"> 57355 </span>8<span class="number"> 2 </span>95A57C3BAB7849DBCDDF7C72ADA71A88146B141110318CA5BE672057 E865C3E2</span><br><span class="line">io.                    <span class="number"> 86400 </span>  IN      RRSIG   DS<span class="number"> 8 </span>1<span class="number"> 86400 </span>20210419170000<span class="number"> 20210406160000 </span>14631 . LesMUo9DIF7nZqdiU1/I8zkBc2tH/eGmSngiWhaWTdHc6GhiXYmuMOY3 PGaGLE0dp99x1sQSvs5lRuYIqH5XGRYvvtzQjibGN12X4MqdzqAqsNEN MUdDE60ACi7qlGck87c4a66yeFsgShi/3mC95E2JnsZMWiHNcdgN0vrS zpBMDSvDYtE+VtwHOydLztjym6oZrmNEbIWYQ9ZExLZWaB5DehvZpXcC xSheLgKdYM/r1OBEuyqRZhwzXn7gwu6nmwKRQQuCK2pDV4ZEwjuZphlW nZL7wdKSAlfh2HIyT6pCvuOnwn8Hv7JPUWzciNBS7sWHOTcSTpD7Offc jqCDEQ==</span><br><span class="line">;; Received<span class="number"> 660 </span>bytes from 2001:500:1::53<span class="comment">#53(h.root-servers.net) in 21 ms</span></span><br><span class="line"></span><br><span class="line">github.io.             <span class="number"> 86400 </span>  IN      NS      dns2.p05.nsone.net.</span><br><span class="line">github.io.             <span class="number"> 86400 </span>  IN      NS      ns-692.awsdns-22.net.</span><br><span class="line">github.io.             <span class="number"> 86400 </span>  IN      NS      dns3.p05.nsone.net.</span><br><span class="line">github.io.             <span class="number"> 86400 </span>  IN      NS      ns-1622.awsdns-10.co.uk.</span><br><span class="line">github.io.             <span class="number"> 86400 </span>  IN      NS      dns1.p05.nsone.net.</span><br><span class="line">0d790076pp5pfktg2hrthj5bj6ckckcb.io.<span class="number"> 900 </span>IN NSEC3<span class="number"> 1 </span>1<span class="number"> 10 </span>332539EE7F95C32A 0D7BD4G2J0SLS1QJ0OVHK6NSRI6V9MIK NS SOA RRSIG DNSKEY NSEC3PARAM</span><br><span class="line">0d790076pp5pfktg2hrthj5bj6ckckcb.io.<span class="number"> 900 </span>IN RRSIG NSEC3<span class="number"> 8 </span>2<span class="number"> 900 </span>20210428091714<span class="number"> 20210407081714 </span>31080 io. WNkdcw4u54lGQaemuSd4RWHn2KMvrXDroN+hP0OrRKd6UlmyCfTVO2tm sLUnVdAdollhmKiq6BNYwkZ1dO+B1It8b7NSUY94d4wmxfC/4ePScXyp wmM0aQXOxQHskWksUmtym1793RKTJFxOOZWoB1epWattt4+eW8o+Ne79 zeo=</span><br><span class="line">0jecjt17pqtnq6cj627kpnf4n06hphai.io.<span class="number"> 900 </span>IN NSEC3<span class="number"> 1 </span>1<span class="number"> 10 </span>332539EE7F95C32A 0JES1F5OD9SG1E4CCRGBS865PMBUV4PC NS DS RRSIG</span><br><span class="line">0jecjt17pqtnq6cj627kpnf4n06hphai.io.<span class="number"> 900 </span>IN RRSIG NSEC3<span class="number"> 8 </span>2<span class="number"> 900 </span>20210422151640<span class="number"> 20210401141640 </span>31080 io. jCQEKBD8H79jGL2KZqtCm9YC2ptX2j9v9ZON2IbkNgCEsd3s08tITkPT krnxJ9ksiZLqHzMR86ejBAtIEFpheQIFJG7n6CzYOlGUsC3dc5NPYlp1 jVzr/bifk9Cft2gcl/A726Eg1QjpLGIC3BqJMryKyt9Kh7ymip9o4oOR 7Ts=</span><br><span class="line">;; Received<span class="number"> 686 </span>bytes from 2a01:8840:9e::17<span class="comment">#53(a0.nic.io) in 94 ms</span></span><br><span class="line"></span><br><span class="line">rheinhauss.github.io.  <span class="number"> 3600 </span>   IN      A       185.199.108.153</span><br><span class="line">rheinhauss.github.io.  <span class="number"> 3600 </span>   IN      A       185.199.109.153</span><br><span class="line">rheinhauss.github.io.  <span class="number"> 3600 </span>   IN      A       185.199.111.153</span><br><span class="line">rheinhauss.github.io.  <span class="number"> 3600 </span>   IN      A       185.199.110.153</span><br><span class="line">github.io.             <span class="number"> 900 </span>    IN      NS      dns1.p05.nsone.net.</span><br><span class="line">github.io.             <span class="number"> 900 </span>    IN      NS      dns2.p05.nsone.net.</span><br><span class="line">github.io.             <span class="number"> 900 </span>    IN      NS      dns3.p05.nsone.net.</span><br><span class="line">github.io.             <span class="number"> 900 </span>    IN      NS      dns4.p05.nsone.net.</span><br><span class="line">github.io.             <span class="number"> 900 </span>    IN      NS      ns-1339.awsdns-39.org.</span><br><span class="line">github.io.             <span class="number"> 900 </span>    IN      NS      ns-1622.awsdns-10.co.uk.</span><br><span class="line">github.io.             <span class="number"> 900 </span>    IN      NS      ns-393.awsdns-49.com.</span><br><span class="line">github.io.             <span class="number"> 900 </span>    IN      NS      ns-692.awsdns-22.net.</span><br><span class="line">;; Received<span class="number"> 339 </span>bytes from 2600:9000:5302:b400::1<span class="comment">#53(ns-692.awsdns-22.net) in 39 ms</span></span><br></pre></td></tr></table></figure>
<p>可知，最终解析得到的是四个A记录。</p>
<p>对于只在GitHub的repo设置里配置Custom Domain的情况，在第一步就会失败；对于只在DNS提供商那里设置CNAME的情况，这两步都能顺利执行得到四个A记录。但是直接访问此ip是无法访问我们的 Github Pages 的。原因在于请求头里的 <code>Host</code> 字段。</p>
<p>我们知道，不同的域名通过A记录或者CNAME方式可以连接都同一个IP下，同一个IP也可以设置多个不同站点，那我访问不同的域名都转发到同一IP，怎么区分这些不同的站点呢，就是用的Host字段。Host字段就是"originally requested domain"，相当于我们在地址栏里输入的域名。</p>
<p>访问 <code>null.sakuya.world</code> 时 Fiddler 抓包可发现</p>
<figure>
<img src="/2021/04/07/Github-Pages%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D%E5%8E%9F%E7%90%86/image-20210407173303458.png" alt="image-20210407173303458"><figcaption aria-hidden="true">image-20210407173303458</figcaption>
</figure>
<p>因此我们可以得知，当 Github Pages 接受到的 HTTP 请求中， Host 字段的内容在CNAME文件里有描述时，返回对应仓库中的内容。</p>
<h2 id="后记">后记</h2>
<p>Github pages 的文档中有一段话</p>
<blockquote>
<p><strong>Warning:</strong> We strongly recommend not using wildcard DNS records, such as <code>*.example.com</code>. A wildcard DNS record will allow anyone to host a site at one of your subdomains.</p>
</blockquote>
<p>即不要用 <code>*.example.com</code> 的 CNAME 用于 Github pages服务。原因就是任何人都可以在Github pages利用你的子域名。如果 xxx.example.com 已被用于现有的 github pages 服务，那么添加 Custom Domain 时会有提示；如果还没有占用，则可以添加</p>
<p><img src="/2021/04/07/Github-Pages%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%9F%E5%90%8D%E5%8E%9F%E7%90%86/image-20210407175359804.png" alt="image-20210407175359804" style="zoom:80%;"></p>
<p>此时如果DNS记录里含有 <code>*.example.com</code> 的CNAME记录，那么就可以用这个子域名成功访问pages。</p>
<p>有人可能会好奇，不是CNAME到 <code>rheinhauss.github.io</code> 吗？这个是我自己的pages服务呀？原因在于，<code>*.github.io</code>，或者说整个pages服务最终就解析到那几个ip，效果是一样的。</p>
<p>语无伦次，请见谅。</p>
]]></content>
      <tags>
        <tag>网络</tag>
        <tag>DNS</tag>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title>Synth-V根据颤音自动画响度插件</title>
    <url>/2021/04/06/Synth-V%E6%A0%B9%E6%8D%AE%E9%A2%A4%E9%9F%B3%E8%87%AA%E5%8A%A8%E7%94%BB%E5%93%8D%E5%BA%A6%E6%8F%92%E4%BB%B6/</url>
    <content><![CDATA[<p>一个月前给Synth V写了个脚本，用于根据颤音自动画响度，解放双手，再也不用握着鼠标描参数曲线辣！<strong>项目地址</strong>：<a href="https://github.com/Rheinhauss/SynthV_plugin_auto_loudness_by_vibrato">Rheinhauss/SynthV_plugin_auto_loudness_by_vibrato</a></p>
<p>暂时只有<code>覆盖原响度</code>和<code>叠加在原响度上</code>的模式。可以自行设置合适的强度和曲线精度（每四分音符 参数点的数量），也可以选择是否简化响度曲线。</p>
<h3 id="用法">用法</h3>
<p>选取（可多选）你想让本插件处理的音符，点击<code>脚本 -&gt; tool -&gt; 根据颤音设置响度</code>，设置合适的参数，然后执行。</p>
<h3 id="注意">注意</h3>
<p>不支持在音符内部有bpm改变的情况</p>
<h3 id="小记">小记</h3>
<p>其实还挺简单的，Synth V颤音参数描述的就是一个正弦曲线，所以：</p>
<ol type="1">
<li><p>遍历获取相应音符颤音参数</p></li>
<li><p><code>Math.sin()；</code></p></li>
<li><p>写入</p></li>
</ol>
<p>就完事了。</p>
<p>麻烦的地方在于一点点文档里没有说明<em>（或者我没看到..）</em>的坑：</p>
<ul>
<li><p>音符如果没有设置相关参数，则获取出来是 <code>NaN</code> ，所以要形如 <code>if (isNaN(n.attr.tF0VbrStart)) n.attr.tF0VbrStart = attrDefault.tF0VbrStart;</code> 来fallback到音轨的默认参数上；</p></li>
<li><p>音轨如果没有设置默认参数，则获取出来是 <code>undefined</code> ，所以要形如 <code>if (attrDefault.tF0VbrStart === undefined) attrDefault.tF0VbrStart = 0.250;</code> 检查一下；</p></li>
<li><p>文档里没说一些重要的对象怎么获得<em>（或者我没看到..）</em>，所以要么找官方示例要么自己摸索。</p></li>
</ul>
]]></content>
      <tags>
        <tag>Synth V</tag>
      </tags>
  </entry>
  <entry>
    <title>Synthesizer-V-设置全局缩放的方法</title>
    <url>/2021/04/06/Synthesizer-V-%E8%AE%BE%E7%BD%AE%E5%85%A8%E5%B1%80%E7%BC%A9%E6%94%BE%E7%9A%84%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>众所周知，Synth V Studio在默认的 <code>NotoSansCJKjp-Regular</code> 字体下，界面渲染十分难受，用户看不清字，特别是高分屏，眼睛都快瞎了（），令人无比想念可以在设置内调整界面和字体缩放的第一代Synth V。</p>
<p>解决办法目前有俩：</p>
<ol type="1">
<li>换字体。<code>Synth-V-Studio安装路径\fonts\</code>下替换<code>NotoSansCJKjp-Regular.otf</code>即可。个人推荐使用 <code>Microsoft Yahei Mono</code> （虽然是网友自行拼接<code>微软雅黑</code>和 <code>Consolas</code> 而成的 ），<strong><em>不过可能会有版权问题</em></strong>。`<code>Synth V Studio</code> 每次升级后都要重新覆盖字体。</li>
<li>通过命令行加参数 <code>--with-scaling &lt;放大倍数&gt;</code> 的方式启动 <code>synthv-studio.exe</code> 。为方便起见可以将此保存成一个快捷方式。 <img src="/2021/04/06/Synthesizer-V-%E8%AE%BE%E7%BD%AE%E5%85%A8%E5%B1%80%E7%BC%A9%E6%94%BE%E7%9A%84%E6%96%B9%E6%B3%95/image-20210406152541899.png" alt="image-20210406152541899"></li>
</ol>
]]></content>
      <categories>
        <category>Miscellaneous</category>
      </categories>
      <tags>
        <tag>Synth V</tag>
      </tags>
  </entry>
  <entry>
    <title>UMLpre_01</title>
    <url>/2021/04/21/UMLpre-01/</url>
    <content><![CDATA[<h2 id="一.-项目前景和范围"><strong>一.</strong> <strong>项目前景和范围</strong></h2>
<h3 id="项目前景">1. 项目前景</h3>
<h4 id="在校生通过全面课程提醒来提升学习效率"><strong>在校生通过全面课程提醒来提升学习效率</strong></h4>
<p>本项目以实用功能为设计基础，注重实用方面的用户体验。针对在校生用户，每天面对繁多的课程和作业，本项目提供全校所有课程的基本信息，包括课程名称，上课时间地点任课老师，对应作业及截止时间提醒等，帮助用户安排学习日程，以达到提升用户学习效率的目的。</p>
<h3 id="项目范围">2. 项目范围</h3>
<h4 id="在校学生"><strong>在校学生</strong></h4>
<p>通过自身账号登录系统查看自己全部的课程内容及相应作业，</p>
<p>参与讨论区评价</p>
<p>与教师互动</p>
<h4 id="系统管理者"><strong>系统管理者</strong></h4>
<p>对程序进行更新</p>
<h2 id="二-涉众分析"><strong>二、</strong> <strong>涉众分析</strong></h2>
<h3 id="涉众概要"><strong>1.</strong> 涉众概要</h3>
<table>
<thead>
<tr class="header">
<th><strong>涉众编号</strong></th>
<th><strong>涉众名称</strong></th>
<th><strong>涉众说明</strong></th>
<th><strong>使用系统的方式</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>001</strong></td>
<td>普通学生</td>
<td>学生是使用该系统导入获取课程信息的主体</td>
<td>1. 设置可按周显示的课表 <br>2. 设置并获取课程提醒信息 <br>3. 创建作业待办</td>
</tr>
<tr class="even">
<td><strong>002</strong></td>
<td>系统开发人员</td>
<td>系统开发人员是对系统进行开发和维护的人员</td>
<td>1. 开发课程提醒系统 <br>2. 对程序进行更新</td>
</tr>
</tbody>
</table>
<h3 id="涉众简档"><strong>2. 涉众简档</strong></h3>
<h4 id="普通学生"><strong>2.1</strong> <strong>普通学生</strong></h4>
<table>
<thead>
<tr class="header">
<th><strong>涉众</strong></th>
<th><strong>001普通学生</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>涉众代表</strong></td>
<td><strong>普通用户代表</strong></td>
</tr>
<tr class="even">
<td><strong>特点</strong></td>
<td><strong>系统的主要使用者,在校大学生</strong></td>
</tr>
<tr class="odd">
<td><strong>职责</strong></td>
<td><strong>1.</strong> <strong>下载并使用该系统</strong> <br><strong>2.</strong> <strong>导入并修改可按周查看的课表</strong> <br><strong>3.</strong> <strong>获取课前提醒</strong> <br><strong>4.</strong> <strong>添加可备注的待办/作业,可设定提醒时间</strong></td>
</tr>
<tr class="even">
<td><strong>成功标准</strong></td>
<td><strong>1.</strong> <strong>能及时获取课程提醒信息</strong> <br><strong>2.</strong> <strong>课表显示周数,课程名称,时间,教师,教室.</strong></td>
</tr>
<tr class="odd">
<td><strong>参与</strong></td>
<td><strong>不参与系统建设</strong></td>
</tr>
<tr class="even">
<td><strong>可交付工作</strong></td>
<td><strong>无</strong></td>
</tr>
</tbody>
</table>
<h4 id="系统管理员"><strong>2.2</strong> <strong>系统管理员</strong></h4>
<table>
<thead>
<tr class="header">
<th><strong>涉众</strong></th>
<th><strong>002系统开发人员</strong></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>涉众代表</strong></td>
<td><strong>开发人员代表</strong></td>
</tr>
<tr class="even">
<td><strong>特点</strong></td>
<td><strong>系统的开发者</strong></td>
</tr>
<tr class="odd">
<td><strong>职责</strong></td>
<td><strong>1.</strong> <strong>开发课程提醒系统</strong> <strong>2.</strong> <strong>对系统使用中出现的问题进行维护和修复</strong></td>
</tr>
<tr class="even">
<td><strong>成功标准</strong></td>
<td><strong>课程提醒系统运行良好</strong></td>
</tr>
<tr class="odd">
<td><strong>参与</strong></td>
<td><strong>参与系统设计</strong></td>
</tr>
<tr class="even">
<td><strong>可交付工作</strong></td>
<td><strong>课程题型系统</strong></td>
</tr>
</tbody>
</table>
<h2 id="三-硬数据采样"><strong>三、 硬数据采样</strong></h2>
<h3 id="硬数据采样内容"><strong>1. 硬数据采样内容</strong></h3>
<p><strong>采用调查问卷形式,问卷内容及结果如下</strong></p>
<figure>
<img src="/2021/04/21/UMLpre-01/clip_image002.jpg" alt="img"><figcaption aria-hidden="true">img</figcaption>
</figure>
<figure>
<img src="/2021/04/21/UMLpre-01/clip_image004.jpg" alt="img"><figcaption aria-hidden="true">img</figcaption>
</figure>
<figure>
<img src="/2021/04/21/UMLpre-01/clip_image006.jpg" alt="img"><figcaption aria-hidden="true">img</figcaption>
</figure>
<h3 id="硬数据采样结果分析"><strong>2.硬数据采样结果分析</strong></h3>
<ol type="1">
<li>有效填写人次54，其中大部分为大一、大二学生</li>
</ol>
<figure>
<img src="/2021/04/21/UMLpre-01/clip_image008.png" alt="img"><figcaption aria-hidden="true">img</figcaption>
</figure>
<ol start="2" type="1">
<li>有2/3的人偶尔在学习生活中错过ddl,对此程序的必要性做出了佐证</li>
</ol>
<figure>
<img src="/2021/04/21/UMLpre-01/clip_image010.png" alt="img"><figcaption aria-hidden="true">img</figcaption>
</figure>
<ol start="3" type="1">
<li>76%的人认为需要课程提醒,证明了本项目的可行性</li>
</ol>
<figure>
<img src="/2021/04/21/UMLpre-01/clip_image012.png" alt="img"><figcaption aria-hidden="true">img</figcaption>
</figure>
<ol start="4" type="1">
<li><strong>结果显示对于：移动设备上的文字通知，桌面设备上的弹窗或窗口，动设备上的铃声、震动，每天定时短信方式发送至手机 四种提醒方式选择人数相似，可以考虑让用户自行选择设置提醒方式</strong></li>
</ol>
<figure>
<img src="/2021/04/21/UMLpre-01/clip_image014.png" alt="img"><figcaption aria-hidden="true">img</figcaption>
</figure>
<ol start="5" type="1">
<li><strong>对于 课程提醒时间 大多数人[85%]选择了每天定时提醒</strong></li>
</ol>
<figure>
<img src="/2021/04/21/UMLpre-01/clip_image016.png" alt="img"><figcaption aria-hidden="true">img</figcaption>
</figure>
]]></content>
      <categories>
        <category>课程</category>
      </categories>
      <tags>
        <tag>UML需求工程</tag>
        <tag>作业</tag>
      </tags>
  </entry>
  <entry>
    <title>UMLpre_02</title>
    <url>/2021/05/19/UMLpre-02/</url>
    <content><![CDATA[<p>这次主要是数据建模相关的结果。</p>
<h2 id="erd">ERD</h2>
<h3 id="简单情况erd建模">简单情况ERD建模</h3>
<figure>
<img src="/2021/05/19/UMLpre-02/image-20210519151540050.png" alt="image-20210519151540050"><figcaption aria-hidden="true">image-20210519151540050</figcaption>
</figure>
<h3 id="根据硬表单的erd建模">根据硬表单的ERD建模</h3>
<figure>
<img src="/2021/05/19/UMLpre-02/image-20210519151600681.png" alt="image-20210519151600681"><figcaption aria-hidden="true">image-20210519151600681</figcaption>
</figure>
<h2 id="dfd">DFD</h2>
<h3 id="上下文图">上下文图</h3>
<figure>
<img src="/2021/05/19/UMLpre-02/image-20210519151632864.png" alt="image-20210519151632864"><figcaption aria-hidden="true">image-20210519151632864</figcaption>
</figure>
<h3 id="层图">0层图</h3>
<figure>
<img src="/2021/05/19/UMLpre-02/image-20210519151643756.png" alt="image-20210519151643756"><figcaption aria-hidden="true">image-20210519151643756</figcaption>
</figure>
<h3 id="层图-1">1层图</h3>
<figure>
<img src="/2021/05/19/UMLpre-02/image-20210519151653038.png" alt="image-20210519151653038"><figcaption aria-hidden="true">image-20210519151653038</figcaption>
</figure>
<h2 id="微规格说明"><strong>微规格说明</strong></h2>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">OPEN</span> bitClassSchedule.app</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">CASE</span></span><br><span class="line">CASE1 (<span class="keyword">without</span>-ClassTable-<span class="keyword">database</span>)</span><br><span class="line">4Action1: <span class="keyword">show</span> <span class="keyword">add</span> data <span class="keyword">View</span></span><br><span class="line">4Action2: <span class="keyword">get</span> the classSchedule <span class="keyword">Input</span>(.xls File)</span><br><span class="line">4Action3: <span class="keyword">create</span> the ClassTable <span class="keyword">database</span></span><br><span class="line">CASE2(ClassTable-Created)</span><br><span class="line">4Action1: <span class="keyword">show</span> the basic main <span class="keyword">Window</span></span><br><span class="line">4Action2: count <span class="type">date</span></span><br><span class="line">Action3: <span class="keyword">create</span> Button[本周课表] <span class="keyword">and</span> [我的作业待办]</span><br><span class="line">Action4: <span class="keyword">search</span> the <span class="keyword">DataBase</span> <span class="keyword">and</span> <span class="keyword">show</span> today’s <span class="keyword">class</span> information</span><br><span class="line">Action(OnClickButton[本周课表]): change <span class="keyword">View</span> <span class="keyword">to</span> bzkebiao</span><br><span class="line">4Action1: <span class="keyword">create</span> basic layout</span><br><span class="line">4Action2: count week</span><br><span class="line">Action3: <span class="keyword">search</span> the ClassTable.db <span class="keyword">database</span> <span class="keyword">and</span> <span class="keyword">create</span> the bzkebiao</span><br><span class="line">Action4: <span class="keyword">set</span> OnClickListener(show_class_information) <span class="keyword">on</span> <span class="keyword">all</span> the <span class="keyword">class</span> textview shown <span class="keyword">on</span> bzkebiao.xml</span><br><span class="line">Action(OnClickTextView[show_class_information]):</span><br><span class="line">4Action1: Alert <span class="keyword">View</span> class_inf_basic.xml</span><br><span class="line">Action2: <span class="keyword">Search</span> ClassTable.db, collect <span class="keyword">and</span> <span class="keyword">show</span> <span class="keyword">all</span> the Information <span class="keyword">or</span> the chosen <span class="keyword">class</span> </span><br><span class="line">4Action(OnClickButton[我的作业待办]):change <span class="keyword">View</span> <span class="keyword">to</span> daiban.xml</span><br><span class="line">44Action1: <span class="keyword">create</span> the basic layout(<span class="keyword">with</span> “<span class="keyword">add</span>”,”clear” button)</span><br><span class="line">Action2: <span class="keyword">database</span>(daiban.db) <span class="keyword">exists</span>? <span class="keyword">Read</span> daiban.db : <span class="keyword">create</span> daiban.<span class="keyword">database</span></span><br><span class="line">44Action3: sort <span class="keyword">all</span> the daiban_work <span class="keyword">by</span> <span class="type">time</span>, <span class="keyword">show</span></span><br><span class="line">44Action(OnClick “<span class="keyword">add</span>” Button):</span><br><span class="line">444Action1: Change <span class="keyword">to</span> <span class="keyword">View</span> add_daiban.xml</span><br><span class="line">444Action2: <span class="keyword">write</span> the daiban_work information</span><br><span class="line">444Action3: put daiban_work <span class="keyword">in</span> <span class="keyword">database</span></span><br><span class="line">44Action(OnClickButton[clear]):</span><br><span class="line">444Action1: remove daiban.db</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="数据字典"><strong>数据字典</strong></h2>
<table>
<colgroup>
<col style="width: 21%">
<col style="width: 78%">
</colgroup>
<thead>
<tr class="header">
<th>名称</th>
<th>课程信息</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>别名</td>
<td></td>
</tr>
<tr class="even">
<td>使用的地点和方法</td>
<td>保存课程信息(input) <br>显示今日课程(output) <br>展示本周课程信息(output) <br>发送课程信息(input) <br>显示课程详细信息(output)</td>
</tr>
<tr class="odd">
<td>描述</td>
<td>1. <code>Classname = Text</code> <br>2. <code>Zhouci = [”&#123;1~20&#125;-&#123;1~20&#125;周” or”&#123;1~20&#125;周” ]  例:1-8周\| 12周</code> <br>3. <code>Kaishi =[第&#123;1-13&#125;节]</code> <br>4. <code>Jieshu=[第&#123;1-13&#125;节]</code> <br>5. <code>Teacher=text</code> <br>6. <code>教室 = text</code></td>
</tr>
<tr class="even">
<td>格式</td>
<td><code>SQLite database Information  In table Class</code></td>
</tr>
</tbody>
</table>
<table>
<colgroup>
<col style="width: 21%">
<col style="width: 78%">
</colgroup>
<thead>
<tr class="header">
<th>名称</th>
<th>待办</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>别名</td>
<td>Daiban_work(in AddView.java and MyTask.java)</td>
</tr>
<tr class="even">
<td>使用的地点和方法</td>
<td>存储待办(input)<br> 显示待办(output)<br> 删除待办(input)<br> 查找待办(output)</td>
</tr>
<tr class="odd">
<td>描述</td>
<td>1. <code>Created_time = [2021+]Year+[1-12]month+[1-31]date+[0-24]hour+[0-60]min</code><br> 2. <code>Inf= text</code><br> 3. <code>Deadline=同Create_time</code><br> 4. <code>Remind_time=同Create_time</code></td>
</tr>
<tr class="even">
<td>格式</td>
<td><code>SQLite database Information  In table daiban.db</code></td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>课程</category>
      </categories>
      <tags>
        <tag>UML需求工程</tag>
        <tag>作业</tag>
      </tags>
  </entry>
  <entry>
    <title>UMLpre_03</title>
    <url>/2021/05/19/UMLpre-03/</url>
    <content><![CDATA[<p>课程提醒系统demo的repo在此：https://gitee.com/i-dont-miss-it/bitClassScheduleApp</p>
<h3 id="changelog">ChangeLog</h3>
<p>（待完成…）</p>
]]></content>
      <categories>
        <category>课程</category>
      </categories>
      <tags>
        <tag>UML需求工程</tag>
        <tag>作业</tag>
      </tags>
  </entry>
  <entry>
    <title>cpp_vector_用迭代器初始化</title>
    <url>/2021/04/13/cpp-vector-%E7%94%A8%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%88%9D%E5%A7%8B%E5%8C%96/</url>
    <content><![CDATA[<p>前几日突发奇想，既然可以用迭代器给vector初始化，那如果用一些奇奇怪怪的迭代器进行初始化会怎么样呢？话不多说，实验一下(环境为<code>gcc 9.3.0-17ubuntu1~20.04</code>)，代码如下。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要c++11</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span>* argv[])</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; vec1&#123;<span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; vec2&#123;<span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> a = &#123;vec2.<span class="built_in">end</span>(), vec1.<span class="built_in">begin</span>()&#125;;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">vec3</span><span class="params">(a)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">vec4</span><span class="params">(vec1.end(), vec2.begin())</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">vec5</span><span class="params">(vec1.end(), vec1.begin())</span></span>;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; vec6&#123;vec1.<span class="built_in">end</span>(), vec2.<span class="built_in">begin</span>()&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>是搞出来了两个迭代器作为元素的vector呢还是直接复制两个迭代器地址之间的内容？</p>
<p>实验结果是：</p>
<ul>
<li><p><code>vec3</code>导致编译时报错</p>
<p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">没有与参数列表匹配的构造函数 <span class="string">&quot;std::vector&lt;_Tp, _Alloc&gt;::vector [其中 _Tp=int, _Alloc=std::allocator&lt;int&gt;]&quot;</span> 实例 -- 参数类型为:  (std::initializer_list&lt;__gnu_cxx::__normal_iterator&lt;<span class="keyword">int</span> *, std::vector&lt;<span class="keyword">int</span>, std::allocator&lt;<span class="keyword">int</span>&gt;&gt;&gt;&gt;)</span><br></pre></td></tr></table></figure></p></li>
<li><p><code>vec5</code>导致运行时报错</p>
<p><figure class="highlight smali"><table><tr><td class="code"><pre><span class="line">terminate called after throwing an<span class="built_in"> instance </span>of &#x27;std::length_error&#x27;</span><br><span class="line">  what():  cannot create std::vector larger than max_size()</span><br></pre></td></tr></table></figure></p></li>
<li><p>注释掉<code>vec3</code>、<code>vec5</code>后，可发现其余vector内部存放的数据 <img src="/2021/04/13/cpp-vector-%E7%94%A8%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%88%9D%E5%A7%8B%E5%8C%96/image-20210413210624685.png" alt="image-20210413210624685" style="zoom:80%;"></p></li>
</ul>
<p>以上结果是为什么呢？</p>
<p>首先介绍一下背景知识：</p>
<ul>
<li><p>C++11引入了新类型，叫做 <code>std::initializer_list</code>，即大括号初始化列表，用于列表初始化一个对象。 当遇到以下情况时一个<code>initializer_list</code>被自动创建（copy自cppreference）：</p>
<ul>
<li>a <em>braced-init-list</em> is used to <a href="https://en.cppreference.com/w/cpp/language/list_initialization">list-initialize</a> an object, where the corresponding constructor accepts an <code>std::initializer_list</code> parameter</li>
<li>a <em>braced-init-list</em> is used as the right operand of <a href="https://en.cppreference.com/w/cpp/language/operator_assignment#Builtin_direct_assignment">assignment</a> or as a <a href="https://en.cppreference.com/w/cpp/language/overload_resolution#Implicit_conversion_sequence_in_list-initialization">function call argument</a>, and the corresponding assignment operator/function accepts an <code>std::initializer_list</code> parameter</li>
<li>a <em>braced-init-list</em> is bound to <a href="https://en.cppreference.com/w/cpp/language/auto"><code>auto</code></a>, including in a <a href="https://en.cppreference.com/w/cpp/language/range-for">ranged for loop</a></li>
</ul>
<p>C++11允许构造函数和其他函数把初始化列表当做参数，使用方法如下</p>
<p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myVector</span> &#123;</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;T&gt; m_vec;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">myVector</span>(<span class="keyword">const</span> std::initializer_list&lt;T&gt;&amp; v) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i : v)</span><br><span class="line">            m_vec.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    T&amp; <span class="keyword">operator</span>[](<span class="keyword">int</span> index) &#123; <span class="keyword">return</span> m_vec[index]; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p></li>
</ul>
<p>背景知识介绍完了，那就来结合源码解释一下实验现象8。</p>
<ul>
<li><p><code>vec3</code>的编译时报错： <code>vec3</code>是<code>vector&lt;int&gt;</code>。接受大括号初始化列表作为参数的构造函数，需要的是内含<code>int</code>的初始化列表，而我们构造的<code>auto a = &#123;vec2.end(), vec1.begin()&#125;;</code>是内含<code>vector&lt;int&gt;::iterator</code>的初始化列表，所以报错<code>没有与参数列表匹配的构造函数</code>。 如果把<code>vec3</code>一行改为<code>vector&lt;vector&lt;int&gt;::iterator&gt; vec3(a);</code>则可以通过编译。</p></li>
<li><p>其余vec的现象的原因是一样的。跟踪代码运行阅读对应源码可知： <img src="/2021/04/13/cpp-vector-%E7%94%A8%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%88%9D%E5%A7%8B%E5%8C%96/image-20210413213612781.png" alt="image-20210413213612781" style="zoom:80%;"></p>
<p><img src="/2021/04/13/cpp-vector-%E7%94%A8%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%88%9D%E5%A7%8B%E5%8C%96/image-20210413213630796.png" alt="image-20210413213630796" style="zoom:80%;"></p>
<p><img src="/2021/04/13/cpp-vector-%E7%94%A8%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%88%9D%E5%A7%8B%E5%8C%96/image-20210413214627923.png" alt="image-20210413213630796" style="zoom:80%;"></p>
<p><img src="/2021/04/13/cpp-vector-%E7%94%A8%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%88%9D%E5%A7%8B%E5%8C%96/image-20210413213653848.png" alt="image-20210413213653848" style="zoom:80%;"></p>
<p><img src="/2021/04/13/cpp-vector-%E7%94%A8%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%88%9D%E5%A7%8B%E5%8C%96/image-20210413213707553.png" alt="image-20210413213707553" style="zoom:80%;"></p>
<p><img src="/2021/04/13/cpp-vector-%E7%94%A8%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%88%9D%E5%A7%8B%E5%8C%96/image-20210413214724940.png" alt="image-20210413213707553" style="zoom:80%;"></p>
<p>如果给vector的构造函数传两个iterator作为参数，那么就从第一个iterator开始读内存做<span class="math inline">\(n=distance(iterator_a, iterator_b)\)</span>次emplace到新的vector里。如果distance超过最大值（这里vec5的情况应该是负溢）则报错。如此一来就能解释vec456的奇妙行为了。当然vec4和vec6没有报错也是环境原因，可能换一个编译器或者系统就会导致那里出错。</p></li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>c++</tag>
      </tags>
  </entry>
  <entry>
    <title>高斯消元解异或方程组</title>
    <url>/2020/08/09/gauss-xor-equation/</url>
    <content><![CDATA[<p>当时遇到了道题，分析之后解异或方程组就完事了。代码如下：</p>
<span id="more"></span>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Gauss</span>(<span class="params">Row: <span class="built_in">int</span>, Column: <span class="built_in">int</span></span>):</span></span><br><span class="line">    row = <span class="number">0</span></span><br><span class="line">    col = <span class="number">0</span></span><br><span class="line">    max_r = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> row &amp;lt; Row <span class="keyword">and</span> col &amp;lt; Column:</span><br><span class="line">        max_r = row</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(row+<span class="number">1</span>, Row):  <span class="comment"># 找出当前列最大值</span></span><br><span class="line">            <span class="keyword">if</span> (Matrix[i][col]) &gt; (Matrix[max_r][col]):</span><br><span class="line">                max_r = i</span><br><span class="line">        <span class="keyword">if</span> Matrix[max_r][col] == <span class="number">0</span>:  <span class="comment"># 记录自由变元</span></span><br><span class="line">            row -= <span class="number">1</span></span><br><span class="line">            Free_x[Free_num] = col+<span class="number">1</span></span><br><span class="line">            Free_num += <span class="number">1</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> max_r != row:  <span class="comment"># 交换</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(col, Column+<span class="number">1</span>):</span><br><span class="line">                tmp = Matrix[row][i]</span><br><span class="line">                Matrix[row][i] = Matrix[max_r][i]</span><br><span class="line">                Matrix[max_r][i] = tmp</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(row+<span class="number">1</span>, Row):  <span class="comment"># 消元</span></span><br><span class="line">            <span class="keyword">if</span> Matrix[i][col] != <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(col, Column+<span class="number">1</span>):</span><br><span class="line">                    Matrix[i][j] ^= Matrix[row][j]</span><br><span class="line">        row += <span class="number">1</span></span><br><span class="line">        col += <span class="number">1</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(row, Row):  <span class="comment"># 无解</span></span><br><span class="line">        <span class="keyword">if</span> Matrix[i][Column] != <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> row &amp;lt; Column:  <span class="comment"># 无穷多解</span></span><br><span class="line">        <span class="keyword">return</span> Column-row</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># 唯一解</span></span><br><span class="line">    i = Column-<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> i &gt;= <span class="number">0</span>:</span><br><span class="line">        X_Ans[i] = Matrix[i][Column]</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>, Column):</span><br><span class="line">            X_Ans[i] ^= Matrix[i][j] <span class="keyword">and</span> X_Ans[j]</span><br><span class="line">        i -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>以Integer类为例的包装类型装箱拆箱与判断相等</title>
    <url>/2021/04/01/%E4%BB%A5Integer%E7%B1%BB%E4%B8%BA%E4%BE%8B%E7%9A%84%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B%E8%A3%85%E7%AE%B1%E6%8B%86%E7%AE%B1%E4%B8%8E%E5%88%A4%E6%96%AD%E7%9B%B8%E7%AD%89/</url>
    <content><![CDATA[<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">app1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer i1 = <span class="number">100</span>;</span><br><span class="line">        Integer j1 = <span class="number">100</span>;</span><br><span class="line">        System.out.println(i1 == j1); <span class="comment">// true </span></span><br><span class="line">        Integer i2 = <span class="number">129</span>;</span><br><span class="line">        Integer j2 = <span class="number">129</span>;</span><br><span class="line">        System.out.println(i2 == j2); <span class="comment">// false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为什么会这样呢.jpg</p>
<span id="more"></span>
<h2 id="分析">分析</h2>
<ol type="1">
<li><p><code>==</code>判断地址相等</p></li>
<li><p>自动装箱时编译器调用<code>valueOf()</code>将原始类型值转换成对象，同时自动拆箱时，编译器通过调用类似<code>intValue()</code>,<code>doubleValue()</code>这类的方法将对象转换成原始类型值。</p>
<ul>
<li><code>Integer c = 200;</code>类似这样触发自动装箱</li>
<li><code>Integer.equals(int a)</code>也对a触发自动装箱</li>
<li><code>Integer == int</code>对<code>Integer</code>类型触发自动拆箱</li>
</ul></li>
<li><p><code>Object.equals()</code>默认</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>Integer.equals()</code>重写成</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Integer) &#123;</span><br><span class="line">            <span class="keyword">return</span> value == ((Integer)obj).intValue();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可见<code>Integer.equals()</code>是比较值。</p></li>
<li><p><code>Integer.intValue()</code></p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">intValue</span><span class="params">()</span>  </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> value;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure></p></li>
<li><p><code>Integer.valueOf()</code></p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在常量池中则返回池中引用，否则创建新的<code>Integer</code>对象。</p></li>
<li><p><code>Integer.IntegerCache</code>常量池</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Cache to support the object identity semantics of autoboxing for values</span></span><br><span class="line"><span class="comment"> * between -128 and 127 (inclusive) as required by JLS.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The cache is initialized on first usage. The size of the cache may be</span></span><br><span class="line"><span class="comment"> * controlled by the &#123;<span class="doctag">@code</span> -XX:AutoBoxCacheMax=&lt;size&gt;&#125; option. During VM</span></span><br><span class="line"><span class="comment"> * initialization, java.lang.Integer.IntegerCache.high property may be set and</span></span><br><span class="line"><span class="comment"> * saved in the private system properties in the jdk.internal.misc.VM class.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * WARNING: The cache is archived with CDS and reloaded from the shared archive</span></span><br><span class="line"><span class="comment"> * at runtime. The archived cache (Integer[]) and Integer objects reside in the</span></span><br><span class="line"><span class="comment"> * closed archive heap regions. Care should be taken when changing the</span></span><br><span class="line"><span class="comment"> * implementation and the cache array should not be assigned with new Integer</span></span><br><span class="line"><span class="comment"> * object(s) after initialization.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerCache</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> low = -<span class="number">128</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> high;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Integer[] cache;</span><br><span class="line">    <span class="keyword">static</span> Integer[] archivedCache;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// high value may be configured by property</span></span><br><span class="line">        <span class="keyword">int</span> h = <span class="number">127</span>;</span><br><span class="line">        String integerCacheHighPropValue = VM.getSavedProperty(<span class="string">&quot;java.lang.Integer.IntegerCache.high&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (integerCacheHighPropValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                h = Math.max(parseInt(integerCacheHighPropValue), <span class="number">127</span>);</span><br><span class="line">                <span class="comment">// Maximum array size is Integer.MAX_VALUE</span></span><br><span class="line">                h = Math.min(h, Integer.MAX_VALUE - (-low) - <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NumberFormatException nfe) &#123;</span><br><span class="line">                <span class="comment">// If the property cannot be parsed into an int, ignore it.</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        high = h;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Load IntegerCache.archivedCache from archive, if possible</span></span><br><span class="line">        VM.initializeFromArchive(IntegerCache.class);</span><br><span class="line">        <span class="keyword">int</span> size = (high - low) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Use the archived cache if it exists and is large enough</span></span><br><span class="line">        <span class="keyword">if</span> (archivedCache == <span class="keyword">null</span> || size &gt; archivedCache.length) &#123;</span><br><span class="line">            Integer[] c = <span class="keyword">new</span> Integer[size];</span><br><span class="line">            <span class="keyword">int</span> j = low;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; c.length; i++) &#123;</span><br><span class="line">                c[i] = <span class="keyword">new</span> Integer(j++);</span><br><span class="line">            &#125;</span><br><span class="line">            archivedCache = c;</span><br><span class="line">        &#125;</span><br><span class="line">        cache = archivedCache;</span><br><span class="line">        <span class="comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span></span><br><span class="line">        <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">IntegerCache</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p><code>Integer(int)</code>构造函数</p>
<p><figure class="highlight aspectj"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Constructs a newly allocated &#123;<span class="doctag">@code</span> Integer&#125; object that</span></span><br><span class="line"><span class="comment">  * represents the specified &#123;<span class="doctag">@code</span> int&#125; value.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span>   value   the value to be represented by the</span></span><br><span class="line"><span class="comment">  *                  &#123;<span class="doctag">@code</span> Integer&#125; object.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@deprecated</span></span></span><br><span class="line"><span class="comment">  * It is rarely appropriate to use this constructor. The static factory</span></span><br><span class="line"><span class="comment">  * &#123;<span class="doctag">@link</span> #valueOf(int)&#125; is generally a better choice, as it is</span></span><br><span class="line"><span class="comment">  * likely to yield significantly better space and time performance.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="meta">@Deprecated</span>(since=<span class="string">&quot;9&quot;</span>)</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">Integer</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">this</span>.value = value;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>官方建议用静态工厂方法<code>valueOf(int)</code>替代本构造函数，因为在时间与空间方面的性能都更好。</p>
<p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer i = Integer.ValueOf(<span class="number">10</span>);</span><br></pre></td></tr></table></figure></p>
<p>具体原因如下：</p>
<ul>
<li><code>Integer.ValueOf(int)</code>中有<code>IntegerCache</code>常量池，相当于做了一个缓存，在缓存范围内的都可以直接从缓存中取，而不必生成新的对象，提高了对象的利用率。</li>
</ul></li>
</ol>
<h2 id="总结">总结</h2>
<p>我们用一段代码来总结各种情况。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">app1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer IntNew200_1 = <span class="keyword">new</span> Integer(<span class="number">200</span>);</span><br><span class="line">        Integer IntNew200_2 = <span class="keyword">new</span> Integer(<span class="number">200</span>);</span><br><span class="line">        Integer IntEqual200_1 = <span class="number">200</span>;</span><br><span class="line">        Integer IntEqual200_2 = <span class="number">200</span>;</span><br><span class="line">        Integer IntNew100_1 = <span class="keyword">new</span> Integer(<span class="number">100</span>);</span><br><span class="line">        Integer IntNew100_2 = <span class="keyword">new</span> Integer(<span class="number">100</span>);</span><br><span class="line">        Integer IntEqual100_1 = <span class="number">100</span>;</span><br><span class="line">        Integer IntEqual100_2 = <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">int</span> IntPri200 = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;两个new出来200\t\t==\t&quot;</span> + (IntNew200_2 == IntNew200_1));</span><br><span class="line">        System.out.println(<span class="string">&quot;两个new出来200\t\tequal\t&quot;</span> + IntNew200_2.equals(IntNew200_1));</span><br><span class="line">        System.out.println(<span class="string">&quot;new出200和int装箱200\t==\t&quot;</span> + (IntNew200_2 == IntEqual200_1));</span><br><span class="line">        System.out.println(<span class="string">&quot;new出200和int装箱200\tequal\t&quot;</span> + (IntNew200_2.equals(IntEqual200_1)));</span><br><span class="line">        System.out.println(<span class="string">&quot;两个int装箱200\t\t==\t&quot;</span> + (IntEqual200_1 == IntEqual200_2));</span><br><span class="line">        System.out.println(<span class="string">&quot;两个int装箱200\t\tequal\t&quot;</span> + (IntEqual200_1.equals(IntEqual200_2)));</span><br><span class="line">        System.out.println(<span class="string">&quot;基本类型200和new出200\t==\t&quot;</span> + (IntPri200 == IntNew200_2));</span><br><span class="line">        System.out.println(<span class="string">&quot;基本类型200和new出200\tequal\t&quot;</span> + (IntNew200_2.equals(IntPri200)));</span><br><span class="line">        System.out.println(<span class="string">&quot;基本类型200和int装箱200\t==\t&quot;</span> + (IntPri200 == IntEqual200_1));</span><br><span class="line">        System.out.println(<span class="string">&quot;基本类型200和int装箱200\tequal\t&quot;</span> + (IntEqual200_1.equals(IntPri200)));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;两个new出来100\t\t==\t&quot;</span> + (IntNew100_2 == IntNew100_1));</span><br><span class="line">        System.out.println(<span class="string">&quot;两个new出来100\t\tequal\t&quot;</span> + IntNew100_2.equals(IntNew100_1));</span><br><span class="line">        System.out.println(<span class="string">&quot;new出100和int装箱100\t==\t&quot;</span> + (IntNew100_2 == IntEqual100_1));</span><br><span class="line">        System.out.println(<span class="string">&quot;new出100和int装箱100\tequal\t&quot;</span> + (IntNew100_2.equals(IntEqual100_1)));</span><br><span class="line">        System.out.println(<span class="string">&quot;两个int装箱100\t\t==\t&quot;</span> + (IntEqual100_1 == IntEqual100_2));</span><br><span class="line">        System.out.println(<span class="string">&quot;两个int装箱100\t\tequal\t&quot;</span> + (IntEqual100_1.equals(IntEqual100_2)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Output:</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">两个<span class="keyword">new</span>出来<span class="number">200</span>          ==      <span class="literal">false</span></span><br><span class="line">两个<span class="keyword">new</span>出来<span class="number">200</span>          equal   <span class="literal">true</span> </span><br><span class="line"><span class="keyword">new</span>出<span class="number">200</span>和<span class="keyword">int</span>装箱<span class="number">200</span>    ==      <span class="literal">false</span></span><br><span class="line"><span class="keyword">new</span>出<span class="number">200</span>和<span class="keyword">int</span>装箱<span class="number">200</span>    equal   <span class="literal">true</span> </span><br><span class="line">两个<span class="keyword">int</span>装箱<span class="number">200</span>          ==      <span class="literal">false</span></span><br><span class="line">两个<span class="keyword">int</span>装箱<span class="number">200</span>          equal   <span class="literal">true</span> </span><br><span class="line">基本类型<span class="number">200</span>和<span class="keyword">new</span>出<span class="number">200</span>   ==      <span class="literal">true</span></span><br><span class="line">基本类型<span class="number">200</span>和<span class="keyword">new</span>出<span class="number">200</span>   equal   <span class="literal">true</span></span><br><span class="line">基本类型<span class="number">200</span>和<span class="keyword">int</span>装箱<span class="number">200</span> ==      <span class="literal">true</span></span><br><span class="line">基本类型<span class="number">200</span>和<span class="keyword">int</span>装箱<span class="number">200</span> equal   <span class="literal">true</span></span><br><span class="line">两个<span class="keyword">new</span>出来<span class="number">100</span>          ==      <span class="literal">false</span></span><br><span class="line">两个<span class="keyword">new</span>出来<span class="number">100</span>          equal   <span class="literal">true</span></span><br><span class="line"><span class="keyword">new</span>出<span class="number">100</span>和<span class="keyword">int</span>装箱<span class="number">100</span>    ==      <span class="literal">false</span></span><br><span class="line"><span class="keyword">new</span>出<span class="number">100</span>和<span class="keyword">int</span>装箱<span class="number">100</span>    equal   <span class="literal">true</span></span><br><span class="line">两个<span class="keyword">int</span>装箱<span class="number">100</span>          ==      <span class="literal">true</span></span><br><span class="line">两个<span class="keyword">int</span>装箱<span class="number">100</span>          equal   <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>对上述Output的理解：</p>
<ol type="1">
<li>调用<code>Integer(int)</code>即创建一个新的对象。<code>==</code>比较地址。</li>
<li><code>Integer.equal()</code>比较值。</li>
<li>调用<code>Integer(int)</code>即创建一个新的对象。<code>==</code>比较地址。</li>
<li><code>Integer.equal()</code>比较值。</li>
<li><code>int</code>自动装箱成<code>Integer</code>，因值大小超出缓存范围，则新建对象，<code>==</code>比较地址。</li>
<li><code>int</code>自动装箱成<code>Integer</code>，<code>Integer.equal()</code>比较值。</li>
<li>比较时<code>Integer</code>自动拆箱成<code>int</code>，原始类型进行比较。</li>
<li>比较时<code>int</code>自动装箱成<code>Integer</code>，<code>equal()</code>比较值。</li>
<li>比较时<code>Integer</code>自动拆箱成<code>int</code>，原始类型进行比较。</li>
<li>比较时<code>int</code>自动装箱成<code>Integer</code>，<code>equal()</code>比较值</li>
<li>调用<code>Integer(int)</code>即创建一个新的对象。<code>==</code>比较地址。</li>
<li><code>Integer.equal()</code>比较值。</li>
<li>调用<code>Integer(int)</code>即创建一个新的对象。<code>==</code>比较地址。</li>
<li><code>Integer.equal()</code>比较值。</li>
<li><code>int</code>自动装箱成<code>Integer</code>，因值大小在缓存范围内，则使用常量池内对象的引用，<code>==</code>比较地址，是同一地址。</li>
<li><code>Integer.equal()</code>比较值。</li>
</ol>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>数字信封及数字签名</title>
    <url>/2021/05/28/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%B0%81%E5%8F%8A%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/</url>
    <content><![CDATA[<h1 id="数字信封及数字签名">数字信封及数字签名</h1>
<p>[toc]</p>
<h2 id="des与对称加密">DES与对称加密</h2>
<p><strong><em>DES现在已经不是一种安全的加密方法，DES标准和3DES标准已逐渐被AES所取代。</em></strong></p>
<p>DES是一种对称加密算法，这类算法在加密和解密时使用相同的密钥，其安全性依靠密钥的长度和保密。 <span class="math display">\[
加密：\quad E_k(\mathbf{M}) = \mathbf{C}\\
解密：\quad D_k(\mathbf{C}) = D_k(E_k(\mathbf{M})) = \mathbf{M}
\]</span> <img src="/2021/05/28/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%B0%81%E5%8F%8A%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/Untitled%20Diagram.svg" alt="Untitled Diagram"></p>
<ul>
<li>优点
<ul>
<li>计算量小，运算速度比公钥加密快很多</li>
</ul></li>
<li>缺点
<ul>
<li>要求双方取得相同的密钥，难以安全地传递密钥</li>
</ul></li>
</ul>
<h2 id="rsa与非对称加密">RSA与非对称加密</h2>
<p>RSA是一种非对称加密算法。非对称加密为数据的加密与解密提供了一个非常安全的方法，它使用了一对密钥——公钥和私钥，私钥只能由一方保管，不能外泄，而公钥则可以发给任何请求它的人，加密和解密需要两个不同的密钥。RSA算法利用了一个数学难题：大整数因数分解。正向操作非常简单，而逆向操作非常困难。</p>
<ul>
<li>优点
<ul>
<li>安全性高</li>
<li>……</li>
</ul></li>
<li>缺点
<ul>
<li>在计算上相当复杂，加密速度慢</li>
<li>……</li>
</ul></li>
</ul>
<h3 id="rsa流程">RSA流程</h3>
<figure>
<img src="/2021/05/28/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%B0%81%E5%8F%8A%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86.svg" alt="非对称加密"><figcaption aria-hidden="true">非对称加密</figcaption>
</figure>
<h4 id="公钥与私钥的产生">公钥与私钥的产生</h4>
<ol type="1">
<li>随机选取两个大质数<span class="math inline">\(p\)</span>和<span class="math inline">\(q\)</span>，其中<span class="math inline">\(p\neq q\)</span></li>
<li>计算<span class="math inline">\(N=p\times q\)</span></li>
<li>计算<span class="math inline">\(r = \varphi(N) = \varphi(p)\times\varphi(q) = (p-1)\times(q-1)\)</span>，具体参见<em>欧拉函数</em></li>
<li>选择一个小于<span class="math inline">\(r\)</span>的整数<span class="math inline">\(e\)</span>，使<span class="math inline">\(e\)</span>与<span class="math inline">\(r\)</span>互质</li>
<li>求<span class="math inline">\(d\)</span>，满足<span class="math inline">\(ed\equiv1\quad \mathrm{mod}\;r\)</span>，参见模逆元</li>
<li>销毁<span class="math inline">\(p\)</span>和<span class="math inline">\(q\)</span></li>
<li><span class="math inline">\((N,e)\)</span>是公钥，<span class="math inline">\((N,d)\)</span>是私钥</li>
</ol>
<h4 id="加密与解密消息">加密与解密消息</h4>
<p><span class="math display">\[
加密\quad\quad c\equiv n^e\quad \mathrm{mod}\;N\\
解密\quad\quad n\equiv c^d\quad \mathrm{mod}\;N
\]</span></p>
<h5 id="证明">证明</h5>
<p>$$ <span class="math display">\[\begin{equation}
\begin{aligned}
c^{d}&amp;\equiv n^{ed}\quad\mathrm{mod}\;N\\
n^{ed}&amp;=n^{1+k\varphi(N)}\\
&amp;=n(n^{\varphi({N})})^h\\
若n,N互质:\\
n^{ed}&amp;\equiv n(1)^h\equiv n\quad\mathrm{mod}\;N\\
若n,N不互质:\\
设\quad
n &amp;= ph\;,\;ed-1 = k(q-1)\\
有\quad
n^{ed}&amp;=(ph)^{ed}\\
&amp;\equiv ph \equiv n\quad \mathrm{mod}\;p\\
n^{ed}&amp;=n^{ed-1}n=n^{k(q-1)}n=(n^{q-1})^kn\\
&amp;\equiv 1^kn\equiv n\quad\mathrm{mod}\;q\\
\\
\implies n^{ed}\equiv&amp; n\quad\mathrm{mod}\;N

\end{aligned}
\end{equation}\]</span> $$</p>
<h3 id="潜在问题">潜在问题</h3>
<h4 id="中间人攻击">中间人攻击</h4>
<h5 id="介绍">介绍</h5>
<p>密钥分配时，若分配公钥和密文传递遭到中间人攻击，理论上双方都不会发现被监听。</p>
<figure>
<img src="/2021/05/28/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%B0%81%E5%8F%8A%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E4%B8%AD%E9%97%B4%E4%BA%BA.svg" alt="非对称中间人"><figcaption aria-hidden="true">非对称中间人</figcaption>
</figure>
<h5 id="解决方式">解决方式</h5>
<p>今天人们一般用可靠的第三方机构签发凭证来防止这样的攻击。详情请参阅<strong><em>CA</em></strong>及<strong><em>PKI</em></strong>。</p>
<h4 id="密钥生成">密钥生成</h4>
<blockquote>
<p>首先要使用概率算法来验证随机产生的大的整数是否质数，这样的算法比较快而且可以消除掉大多数非质数。假如有一个数通过了这个测试的话，那么要使用一个精确的测试来保证它的确是一个质数。</p>
<p>除此之外这样找到的p和q还要满足一定的要求，首先它们不能太靠近，此外p-1或q-1的因子不能太小，否则的话N也可以被很快地分解。</p>
<p>此外寻找质数的算法不能给攻击者任何信息，这些质数是怎样找到的，尤其产生随机数的软件必须非常好。要求是随机和不可预测。这两个要求并不相同。一个随机过程可能可以产生一个不相关的数的系列，但假如有人能够预测出（或部分地预测出）这个系列的话，那么它就已经不可靠了。比如有一些非常好的随机数算法，但它们都已经被发表，因此它们不能被使用，因为假如一个攻击者可以猜出<span class="math inline">\(p\)</span>和<span class="math inline">\(q\)</span>一半的位的话，那么他们就已经可以轻而易举地推算出另一半。</p>
<p>此外密钥d必须足够大，1990年有人证明假如<span class="math inline">\(p\)</span>大于<span class="math inline">\(q\)</span>而小于<span class="math inline">\(2q\)</span>（这是一个很常见的情况）而<span class="math inline">\(d&lt;\frac{1}{3}\times N^{\frac{1}{4}}\)</span>，那么从<span class="math inline">\(N\)</span>和<span class="math inline">\(e\)</span>可以很有效地推算出<span class="math inline">\(d\)</span>。此外<span class="math inline">\(e=2\)</span>永远不应该被使用。</p>
<p><strong><em>Wikipedia</em></strong></p>
</blockquote>
<h2 id="数字信封">数字信封</h2>
<p>为什么？</p>
<ul>
<li>非对称加密算法加密与解密使用不同密钥，安全性高，但是慢</li>
<li>对称加密算法速度快，但是如何安全传递密钥是个问题</li>
</ul>
<p>因此我们想到用非对称加密算法传递对称加密算法的密钥，而用对称加密算法来加密消息本身。</p>
<figure>
<img src="/2021/05/28/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%B0%81%E5%8F%8A%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%B0%81.svg" alt="数字信封"><figcaption aria-hidden="true">数字信封</figcaption>
</figure>
<h2 id="数字签名">数字签名</h2>
<p>通常我们使用公钥加密，用私钥解密。而在数字签名中，我们使用私钥加密（相当于生成签名），公钥解密（相当于验证签名）。可以这么理解：公钥是公开的，私钥是保密的，我们要用一个东西验证信息的发送者，那自然要用公开的公钥来验证；而明文只能加密，密文只能解密，所以验证时是用发送者的公钥对发来的密文进行解密。</p>
<blockquote>
<p>我们可以直接对消息进行签名（即使用私钥加密，此时加密的目的是为了签名，而不是保密），验证者用公钥正确解密消息，如果和原消息一致，则验证签名成功。但通常我们会对消息的散列值签名，因为通常散列值的长度远小于消息原文，使得签名（非对称加密）的效率大大提高。注意，计算消息的散列值不是数字签名的必要步骤。</p>
<p><strong><em>Wikipedia</em></strong></p>
</blockquote>
<p>使用数字签名（不论是原文还是hash值），可以很容易地验证消息完整性和消息来源。</p>
<figure>
<img src="/2021/05/28/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%B0%81%E5%8F%8A%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D.svg" alt="Hash+数字签名"><figcaption aria-hidden="true">Hash+数字签名</figcaption>
</figure>
<h2 id="总体实现">总体实现</h2>
<h3 id="流程图">流程图</h3>
<p><strong><em>图例的使用很不规范，仅作示意用</em></strong></p>
<figure>
<img src="/2021/05/28/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%B0%81%E5%8F%8A%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/diagram-1622201417795.svg" alt="diagram"><figcaption aria-hidden="true">diagram</figcaption>
</figure>
<h3 id="代码模拟">代码模拟</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Hash <span class="keyword">import</span> SHA256</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> DES, PKCS1_OAEP</span><br><span class="line"><span class="keyword">from</span> Crypto.PublicKey <span class="keyword">import</span> RSA</span><br><span class="line"><span class="keyword">from</span> Crypto.Random <span class="keyword">import</span> random, get_random_bytes</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.Padding <span class="keyword">import</span> pad, unpad</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">sender</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, kp</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        self.prik = kp</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">send</span>(<span class="params">self, rawmsg: <span class="built_in">str</span>, lis_pubk</span>):</span></span><br><span class="line">        des_key = get_random_bytes(<span class="number">8</span>)</span><br><span class="line">        rsa_dig_encrypter = PKCS1_OAEP.new(self.prik)</span><br><span class="line">        rsa_desk_encrypter = PKCS1_OAEP.new(lis_pubk)</span><br><span class="line">        des_encrypter = DES.new(des_key, DES.MODE_ECB)</span><br><span class="line">        enc_des_k = rsa_desk_encrypter.encrypt(des_key)</span><br><span class="line">        enc_msg = des_encrypter.encrypt(pad(<span class="built_in">bytes</span>(rawmsg, encoding=<span class="string">&#x27;utf8&#x27;</span>), <span class="number">8</span>))</span><br><span class="line">        raw_dig = SHA256.new()</span><br><span class="line">        raw_dig.update(<span class="built_in">bytes</span>(rawmsg, encoding=<span class="string">&#x27;utf8&#x27;</span>))</span><br><span class="line">        enc_dig = rsa_dig_encrypter.encrypt(</span><br><span class="line">            <span class="built_in">bytes</span>(raw_dig.hexdigest(), encoding=<span class="string">&#x27;utf8&#x27;</span>))</span><br><span class="line">        <span class="keyword">return</span> enc_des_k, enc_msg, enc_dig</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">listener</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, kp</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        self.prik = kp</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">listen</span>(<span class="params">self, com_msg, sender_pubk</span>):</span></span><br><span class="line">        (enc_des_k, enc_msg, enc_dig) = com_msg</span><br><span class="line">        rsa_desk_decrypter = PKCS1_OAEP.new(self.prik)</span><br><span class="line">        rsa_dig_decrypter = PKCS1_OAEP.new(sender_pubk)</span><br><span class="line">        des_key = rsa_desk_decrypter.decrypt(enc_des_k)</span><br><span class="line">        des_decrypter = DES.new(des_key, DES.MODE_ECB)</span><br><span class="line">        dig_recv = <span class="built_in">str</span>(rsa_dig_decrypter.decrypt(enc_dig), encoding=<span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line">        msg = unpad(des_decrypter.decrypt(enc_msg), <span class="number">8</span>)</span><br><span class="line">        challenge_dig = SHA256.new()</span><br><span class="line">        challenge_dig.update(msg)</span><br><span class="line">        <span class="keyword">if</span>(dig_recv == challenge_dig.hexdigest()):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;CHECK PASS&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;CHECK FAILED&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Bob receives a msg from Alice:\n\t&#x27;</span>+<span class="built_in">str</span>(msg, encoding=<span class="string">&#x27;utf8&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    alice_pubk = RSA.generate(<span class="number">2048</span>)</span><br><span class="line">    <span class="comment"># 这里pyCroptodome库出于安全原因禁用了使用公钥解密的操作，因此这里不得不这么写</span></span><br><span class="line">    bob_prik = RSA.generate(<span class="number">2048</span>)</span><br><span class="line">    alice_prik = alice_pubk.public_key()</span><br><span class="line">    bob_pubk = bob_prik.public_key()</span><br><span class="line">    alice = sender(alice_prik)</span><br><span class="line">    bob = listener(bob_prik)</span><br><span class="line">    bob.listen(alice.send(<span class="built_in">input</span>(<span class="string">&#x27;Alice says:\n\t&#x27;</span>), bob_pubk), alice_pubk)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">main()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>课程</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>密码学</tag>
      </tags>
  </entry>
  <entry>
    <title>梦志 2021.05.28</title>
    <url>/2021/05/28/%E6%A2%A6%E5%BF%97-2021-05-28/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again :(" data-whm="Oh, these decrypted content cannot be verified, but you can still have a look :D">
  <script id="hbeData" type="hbeData" data-hmacdigest="8c5c3a8a20faf9fcc7fafa1b299666026d850da65fde3b342c735e1171a5f356">fb7b6e92d8a8d1af19e249503d95625a7e2c880a3249c13db6cbc69b063396b17e7c513c00dffc9539e63138df926d3c026282ca68a23173c1645efadc1eb76ed6c12934fc84f2504865facb4965a7e2abdf4cb293d097e326122e7bb543d1ba5fcfccc7a0c23474d133a8dd245139a4c304430ddbecb51d812100c0e36f40d31d84714f1364526bc41912ebaaff12aa59b1397213a513fb1af6c640b4da63bb11c8d7f6339d63ba977271a5f48d89683d640686b538ed1a883050d408a8b6461fd2aaf7219c5b28731551bc5792fd35504c22c8b5a4d06201d9d82ac3b7df84ad0ef25d40b35a10a81eb3a0941fb4bba2a6d6e3a50e3dcdec8d349f286c193de0c0ad5cf9d2629d991cb4c446f3508e1e7a7f7fd9d7306bf2c8d6b4ebb32ba31b7ea89d80be1a714d7335efc8e52dab2bcf946350876a3c7517cbd140b1bb02f4068f7450bcc2aa6adf5a88d045a66aadda4a7e6bf3916b4778747054482ac0b0a80ddd0be2776942b58270d69a2655aeaab50068b4ae852478eb6958b37663f11cdccdb4ed0a40628ea7f53ed3936a722976612574a6b18f52441caec5dc271b7d6fa0f2526f7ed86fbfb7b176e04433c000f473d72adc8fbea6cd8e9c82a72f2c35f33ee6a2fa49c743eba46b602ffac3ad8eb4c862a4f2db1846bc8a06d299dcf523a8c89a2056e3cdee8f8edadf9468daec392ab071e460e4f82dc58481d4c2985b8ec0d242bbe5507d0c9513e697552b4ac205307f683c735cf022a0a86bc6b85b8674d42b5ca8d7cad49faff6dcbd84af526d58f909d02b6ff4661a6f9b8eaeed42e4f861b73dc7ab73f7f36b22c06025d67814082d2db4e3f7f1c5e91e50832741751c6c5d303a7262524043291c1d7aaf3b995d15432599883c17a7aa732a2428ab66fcc11ef22c5e752a50b84c452f76ad7954980b0458c36cedb1a505c4164ebc33f144ab88c3c22bec9aa64741e8bc8d7b5eaaeede88175cb86c6ae839963ddcc045d091f405515f52a3858634857419b4192d0a64a0c76cc0e5737fd23fe5110f727694a2a47143120b13f5face2475c3a352cff63cf2fbfd30528b69193d62556968eabbc685a5805c41b3bb93de242c26c5a1e111b628eaf4e65016725a4618acb3a07829fedfce8274c50cd0f3ced1b0fc7bc6f0b7888ffc224faa1c9d063b1b5ae9328cd8b1d297ccd0b1a7164ac8e53ede6c62a697ed573664585b565f3202dde916a4325b52df5cdf9f4aaf6893c6e6429eae405d28cf10e45808da3b55eaef2a045ebf94500fc7772fe1365d325e88f528b7604bf3a8d1d1a8069f5f58943b0c8ffbef6d4d46c01cfa1b99cdb9bb24609c1d5d775ac1c7a648420f4bbbd36861462fab7a4e4e4bcdc3c09eeabcb757e365e0eddd5c4b220f43273df5df735b65636c8fbd1c87f62fe24e323b86d321d399cba79847e4c7e072cfb69dccf21dea4e15b5f7f7c9d314968ecee12f64cf86b7c45edc21a43bbee1497f4b69af9f50e95fdd39d31c1203049c179913275d19072260d93ffe256de9cc757ba71b098f3aa5b44884b9288763e3154debcac356afd1be14239def818cac6a5cc664e3ca46ca7b9c88e66630d2c8da9db44e4b1b426747f2571cac980f310337924fc8b886d62b5f4dd73dac0b8c17b6d43a67589b9b9aa0a9dbdd69b9385a247596dfa6174b9c31192b992cfdeedfca0a3efd7de23433ea904841fb3d0d95d79afc2852ce3ee784c630d496b6aaeb5def69044e5acbc02c011ba0f20e728fb34fd2183fb52fe5d03b5846d3b8bced10ca68e8a1d7a834649266162a668ae8fbaffb6f69d1e46a5e4b83366622bcfac66f8392c262cf03dc1bdabd51cd89862d67eb38f34dc039ddb3f2226fd9d006a534e0a0f197c85b84380319436136e612fd631eb6bbb0939a8fe2cd63877694135ca0d9659efb79ad282e1745ad9417eccee37c6ba934b40d2b42693224c94dddedbe70e975c87bd239d52bb7edb6dde9f917aae3490bdca514e9de4a9e0bbeed710835d4e4ff6d3007eeeef0295f6ea30dfcd0b37e9e277fc0918bd5d493bd4591dcf2ddda0609f7b1d2f436bd29dd5a7668c993bc7f2d69d6d0d369305f60e111b775815f1c54a7c9e8afbd8533f5b56e0e8de8bf6be62cf5684594d1620c6a622d6187eccd806fc0d375c0b754d9bb449f66149f4a17babac006a0cb9be162e52c3cfd0133231b2ce656b3fdbfcfee1dc7af11b7358fd9123ce617271f8ba13805129d77d337d1891f4c3edc7584a2482a29a74a280026b07c178c6da6b97d36d3b594d0bc43d5d3d210d669ec77edcabc325721c8c27dec2723f05ca3537e0a595a809ebc5f5a57fab35133a092a10957688df885d2cd2d6b7cb05f3ea8c8a2f429d4eebfbe3e9e47c0b21fa6c584a2b8d6991abbe70f69864f84e57f8c89cf0967d984c3dd613c9506b309bb5cbe51a1d427b42cfaa1a2eb85f443fc7fbc73ccfa8c27957f349b1ad49b76a4437b343d5354527a3ea9bc337d3cca2a681fb20da3489e85b124b88ac9c183a545e54b0e4093805ff2f54593b1e74d28217f4d61af93aef53b90ec96558985a79860da4c4cc1e43bba82ca2afc9b44a3fdb4519d21eac54ee61e67c96d764ea26a1c327e319e79c688c175cced0b1a457da67a1d20388b3a4eadb9c722a3f174dc2c606bc3b75a21c253dbb0331ef9756aef7f1f2960353b07a2c861cc263afc4e6460155a2a2621ecebd8c7836e57f5a198340bb6c447723b52671779781729d5b4847428a2f2b6a62e11307896832200fb579fca16070ebe40b6e42daede27820775b4ba1c3ba51f1bf1fde88c01ae7e008a1321520016695697f6c8363f8991b58f47a9e9d4684c7e50753e6efc1009dc28d928a25144a12985e6e64726e01ede97de76d12fdbd0b8f3622185736ebcb07335921ca4748feca3d79473c56f756a104515608adf6e38d0fe3868069f1a416e4724b5a95747f63f30339a679c95a516f41e84962add0cdd815d04ece88b5a535930983118358ce4549ccb0ad0844346a24b1a9a83728ef72d57310dfa49264c12e3c988b62dfcf36e8b5370dc61e03b94c7198486dc39ecdedaa795d13b78ec87cbd4fac9c6bfe88bbfb9c3bb3802e44d0d739e21afe319b91caa67efb1a69a27022eba8e7b07904cc8edf5f85319aa9742e970825d52ebb8f32babdfa5da14ce1ac3ec6e39ff0ebe42f31f73e9b10f9b402ff15e35adfe9940ef805c1a55609cf9b42c28558827eb5515465fc22ec5195c69b2b483fcdf740fadbd352b405261616c666b3d0395047fb801ef60c1358cad78a3f91e0cebc2832b734272a595f55fe93fc33c62d2c1fbc3c76ef7878802393cee04ce74a48ebdae3b5f31302bda84020881e4b7a659986b4b3542748e84e25c2d875a04862fb9186b51b7a12d144ed83a56e182f3523cd11cebcaa7e6c1352e05f28738cdd3a078c227490cfabbb52811e07a9a1f3d0576cd0eaacf6b90fc5912bf7a92b2a6b36218f0005b3c9de37130ae7612637216dab3fd894178ec836619415e82d37d6d7892d21859a49b349c86b8cb047f7e367c41b026cfafa3152c395d061aee43ee871150286c4ef46254dea8d6e992a63867180b4dca02fc9f5026bf65433ce85fa89f7cb9118b143a8fa0edfd668d0736f4bea293850baacca934c18543c37515528c3f7c90a77c5613c6298de2b76fadd3ed6b452b43e15ab78b548e2fc0bee56d86802f4b0b8597ee9918b83b5daf44da9f654c2b2c269751004bcf68d9f4a402d7c53ad12d8f35e762fe1c4c8515080961959b7008deda98ecc8213e41563acf2ed96beb5618072ca1318c117e4d1aa87b06092efaf6b1a86037b6d3d634fbcecdf6e1576b2517b1d0a6fb7383b91f89dc44a75c9a002bbc6b9a60a5074a802654d6034bb492808307aa25c578a2dd4bcabd59dacb02e1f2a8e78a95b34813e79d5953908eb4b1a96dd6ae0882857225c48a1ede6e2a48fcb6fda8aa3efb312e0929dbe696ced26314c5ba9f79d7b5322df3ade78dae1975a3db32d529456310f592534dbdb039646325248e9d916c19164f058f919ad90ec79eef7c7356ad8e090b6de9f671fb1c98a608a29262a300e9790f992867747775e9904e3e10</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Password required here ;)</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>梦志</tag>
      </tags>
  </entry>
  <entry>
    <title>初探密码学</title>
    <url>/2021/05/28/%E5%88%9D%E6%8E%A2%E5%AF%86%E7%A0%81%E5%AD%A6/</url>
    <content><![CDATA[<h1 id="初探密码学">初探密码学</h1>
<h2 id="引入">引入</h2>
<h3 id="贴吧神贴">贴吧神贴</h3>
<p>https://bbs.hupu.com/32986778.html</p>
<h3 id="意义">意义</h3>
<p><strong><em>如何在不安全（敌人存在）的环境中通信</em></strong></p>
<p>相似问题：</p>
<ul>
<li>工程学——如何利用不可靠的组件构成一个可靠的系统？——容错性
<ul>
<li>e.g. 拜占庭将军问题——各种分布式系统的一致性问题</li>
</ul></li>
</ul>
<p>一般来说，密码设计者的根本目标是保障信息及信息系统的</p>
<ul>
<li>机密性（Confidentiality）</li>
<li>完整性（Integrity）</li>
<li>可用性（Availability）</li>
<li>认证性（Authentication）</li>
<li>不可否认性（Non-repudiation）</li>
</ul>
<p>其中，前三者被称为信息安全的 <strong>CIA</strong> 三要素 。</p>
<p>授权读取信息的人可以轻松通过发信人所提供的密钥解密信息，但未经授权的人员则不行。现代加密技术依赖现代计算机在破解密钥上并不高效的事实来保证其安全性。</p>
<h2 id="几个基本概念与代数基础">几个基本概念与代数基础</h2>
<h3 id="基本概念">基本概念</h3>
<p>明文：需要秘密传送的消息。</p>
<p>密文：明文经过密码变换后的消息。</p>
<p>加密：由明文到密文的变换。</p>
<p>解密：从密文恢复出明文的过程。</p>
<p>破译：非法接收者试图从密文分析出明文的过程。</p>
<p>加密算法：对明文进行加密时采用的一组规则。</p>
<p>解密算法：对密文进行解密时采用的一组规则。</p>
<p>密钥：加密和解密时使用的一组秘密信息。</p>
<p><img src="C:/Users/wangy/AppData/Roaming/Typora/typora-user-images/image-20210528230847591.png" alt="image-20210528230847591" style="zoom:67%;"></p>
<h4 id="攻击">攻击</h4>
<h6 id="唯密文攻击">唯密文攻击</h6>
<p>在仅知密文的情况下进行攻击。</p>
<h6 id="已知明文攻击">已知明文攻击</h6>
<p>指攻击者掌握了某段明文 x 和对应密文 y</p>
<h6 id="选择密文攻击">选择密文攻击</h6>
<p>攻击者掌握对解密机的访问权限，可构造任意密文所对应的明文<code>x</code></p>
<h6 id="选择明文攻击">选择明文攻击</h6>
<p>攻击者拥有加密机的访问权限，可构造所选一定数量的明文所对应的密文</p>
<h6 id="旁路攻击侧信道攻击边信道攻击">旁路攻击、侧信道攻击、边信道攻击</h6>
<p>它基于从密码系统的物理实现中获取的信息而非暴力破解法或是算法中的理论性弱点（较之密码分析）。例如：时间信息、功率消耗、电磁泄露或甚是声音可以提供额外的信息来源，这可被利用于对系统的进一步破解。</p>
<h6 id="社会工程学攻击">社会工程学攻击</h6>
<p>社会工程学指的是通过与他人的合法交流，来使其心理受到影响，做出某些动作或者是透露一些机密信息的方式。这通常被认为是欺诈他人以收集信息、行骗和入侵计算机系统的行为。</p>
<h6 id="section">…………</h6>
<h3 id="代数">代数</h3>
<h5 id="模逆元">模逆元</h5>
<p><span class="math inline">\(ab \equiv 1\mod n\)</span></p>
<p>b是a的模逆元</p>
<h2 id="古典密码学">古典密码学</h2>
<p>主要是代换、置换，以及一堆奇奇怪怪的方法。</p>
<p>应用上也经常组合各种方法加密来增加复杂性。</p>
<h3 id="代换式密码">代换式密码</h3>
<h4 id="单表代换">单表代换</h4>
<h5 id="凯撒密码">凯撒密码</h5>
<p>凯撒密码的替换方法是通过排列明文和密文字母表，密文字母表示通过将明文字母表向左或向右移动一个固定数目的位置。</p>
<h6 id="举例">举例</h6>
<p>例如，当偏移量是左移3的时候（解密时的密钥就是3）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">明文字母表：ABCDEFGHIJKLMNOPQRSTUVWXYZ</span><br><span class="line">密文字母表：DEFGHIJKLMNOPQRSTUVWXYZABC</span><br></pre></td></tr></table></figure>
<h6 id="引出形式描述形式语言的严谨性">引出形式描述——形式语言的严谨性</h6>
<p><span class="math inline">\(E_{n}(x)=(x+n)\mod 26\)</span></p>
<p><span class="math inline">\(D_{n}(x)=(x-n)\mod 26\)</span></p>
<h6 id="多次迭代">多次迭代？</h6>
<p>通过多次使用凯撒密码来加密并不能获得更大的安全性，因为使用偏移量A加密得到的结果再用偏移量B加密，等同于使用A+B的偏移量进行加密的结果。</p>
<h5 id="仿射密码凯撒密码的拓展">仿射密码——凯撒密码的拓展</h5>
<p>仿射密码是一种替换密码。它是一个字母对一个字母的。</p>
<p>它的加密函数是<span class="math inline">\(E(x)=ax+b{\pmod {m}}\)</span>，其中</p>
<ul>
<li>a和m互质。</li>
<li>m是字母的数目。</li>
</ul>
<p>解码函数是<span class="math inline">\(D(x)=a^{-1}(x-b){\pmod {m}}\)</span>，其中<span class="math inline">\(a^{-1}\)</span>是<span class="math inline">\(a\)</span>在 <span class="math inline">\(\mathbb {Z}_m\)</span>群的乘法逆元。</p>
<p>当 <span class="math inline">\(a=1\)</span>，仿射加密为凯撒密码 ，因该加密方程可简化为线性移动。</p>
<h6 id="思考">思考</h6>
<p>多次仿射加密？</p>
<h5 id="莫尔斯电码-等等">莫尔斯电码 等等</h5>
<p>同上，按一个表进行代换。不一定是字符，可以是字体的区别等，如培根密码：培根密码使用两种不同的字体，代表 A 和 B，结合加密表进行加解密。</p>
<h5 id="破译方法">破译方法</h5>
<h6 id="频率分析">频率分析</h6>
<p>当密文长度足够大的情况下，可以先分析密文中每个字母出现的频率，然后将这一频率与正常情况下的该语言字母表中所有字母的出现频率做比较。</p>
<p>例如在英语中，正常明文中字母E和T出现的频率特别高，而字母Q和Z出现的频率特别低，而在法语中出现频率最高的字母是E，最低的是K和W。可以通过这一特点，分析密文字母出现的频率，可以估计出正确的偏移量。</p>
<h6 id="暴力尝试">暴力尝试</h6>
<ul>
<li>凯撒密码：25种；</li>
<li>仿射密码（加密英文）：即<span class="math inline">\(m=26\)</span>时，a和b共有<span class="math inline">\(12\times 26=312\)</span>种可能（12是因为0-26里只有12个数与26互质），很容易就能暴力搜完。</li>
<li>……</li>
</ul>
<h4 id="多表代换">多表代换</h4>
<h5 id="维吉尼亚密码">维吉尼亚密码</h5>
<h5 id="破译方法-1">破译方法</h5>
<h6 id="频率分析-1">频率分析？</h6>
<p>可以吗？明文中重复的元素在密文中并不重复。不行。</p>
<h6 id="卡西斯基试验">卡西斯基试验</h6>
<p>基于类似<code>the</code>这样的常用单词有可能被同样的密钥字母进行加密，从而在密文中重复出现。例如，明文中不同的<code>CRYPTO</code>可能被密钥<code>ABCDEF</code>加密成不同的密文：</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">密钥：ABCDEF AB CDEFA <span class="keyword">BCD </span>EFABCDEFABCD</span><br><span class="line">明文：CRYPTO IS <span class="keyword">SHORT </span>FOR CRYPTOGRAPHY</span><br><span class="line">密文：CSASXT IT UKSWT GQU GWYQVRKWAQJB</span><br></pre></td></tr></table></figure>
<p>此时明文中重复的元素在密文中并不重复。然而，如果密钥相同的话，结果可能便为（使用密钥<code>ABCD</code>）：</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">密钥：ABCDAB CD ABCDA <span class="keyword">BCD </span>ABCDABCDABCD</span><br><span class="line">明文：CRYPTO IS <span class="keyword">SHORT </span>FOR CRYPTOGRAPHY</span><br><span class="line">密文：CSASTP KV SIQUT GQU CSASTPIUAQJB</span><br></pre></td></tr></table></figure>
<p>此时卡西斯基试验就能产生效果。对于更长的段落此方法更为有效，因为通常密文中重复的片段会更多。如通过下面的密文就能破译出密钥的长度：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">密文：DYDUXRMHTVDVNQDQNWDYDUXRMHARTJGWNQD</span><br></pre></td></tr></table></figure>
<p>其中，两个<code>DYDUXRMH</code>的出现相隔了18个字母。因此，可以假定密钥的长度是18的约数，即长度为18、9、6、3或2。而两个<code>NQD</code>则相距20个字母，意味着密钥长度应为20、10、5、4或2。取两者的交集，则可以基本确定密钥长度为2。</p>
<h6 id="弗里德曼试验optional">弗里德曼试验(optional)</h6>
<p>弗里德曼试验由威廉·F·弗里德曼于1920年代发明。他使用了重合指数（index of coincidence）来描述密文字母频率的不匀性，从而破译密码。<span class="math inline">\(\kappa _{p}\)</span>指目标语言中两个任意字母相同的概率（英文中为0.067），<span class="math inline">\(\kappa _{r}\)</span>指字母表中这种情况出现的概率（英文中为<span class="math inline">\(1/26=0.0385\)</span>），从而密钥长度可以估计为：</p>
<p><span class="math display">\[
\kappa _{p}-\kappa _{r} \over {\kappa _{o}-\kappa _{r}}
\]</span> 其中，观察概率为 <span class="math display">\[
\kappa _{o}=\frac{\sum _{i=1}^{c}n_i(n_i-1)}{N(N-1)}
\]</span> 其中，<span class="math inline">\(c\)</span>是指字母表的长度（英文为26），N指文本的长度，<span class="math inline">\(n_1\)</span>到<span class="math inline">\(n_c\)</span>是指密文的字母频率，为整数。</p>
<p>此方法只是一种估计，会随着文本长度的增加而更为精确。在实践中，会尝试接近此估计的多个密钥长度。 一种更好的方法是将密文写成矩阵形式，其中列数与假定的密钥长度一致，将每一列的重合指数单独计算，并求得平均重合指数。对于所有可能的密钥长度，平均重合指数最高的最有可能是真正的密钥长度。这样的试验可以作为卡西斯基试验的补充。</p>
<h6 id="频率分析-2">频率分析</h6>
<p>一旦能够确定密钥的长度，密文就能重新写成多列，列数与密钥长度对应。这样每一列其实就是一个凯撒密码，而此密码的密钥（偏移量）则对应于维吉尼亚密码密钥的相应字母。与破译凯撒密码类似的方法，就能将密文破译。</p>
<h4 id="希尔密码optional">希尔密码（optional）</h4>
<p>希尔密码是运用基本矩阵论原理的替换密码，由Lester S. Hill在1929年发明。</p>
<p>每个字母当作26进制数字：A=0, B=1, C=2... 一串字母当成n维向量，跟一个n×n的矩阵相乘，再将得出的结果模26。</p>
<p>注意用作加密的矩阵（即密匙）在<span class="math inline">\(\mathbb {Z}_{26}^{n}\)</span>必须是可逆的，否则就不可能解码。只有矩阵的行列式和26互质，才是可逆的。</p>
<p>考虑讯息ACT，因为A=0，C=2，T=19，讯息是： <span class="math inline">\(\begin{pmatrix}0\\2\\19\end{pmatrix}\)</span></p>
<p>设密匙为 <span class="math inline">\(\begin{pmatrix}6&amp;24&amp;1\\13&amp;16&amp;10\\20&amp;17&amp;15\end{pmatrix}\)</span></p>
<p>确认它是可逆的：</p>
$
<span class="math display">\[\begin{vmatrix}6&amp;24&amp;1\\13&amp;16&amp;10\\20&amp;17&amp;15\end{vmatrix}\]</span>
<p><span class="math display">\[\equiv 6(16\cdot 15-10\cdot 17)-24(13\cdot 15-10\cdot 20)+1(13\cdot 17-16\cdot 20)\]</span>$</p>
加密过程： $
<span class="math display">\[\begin{pmatrix}6&amp;24&amp;1\\13&amp;16&amp;10\\20&amp;17&amp;15\end{pmatrix}\begin{pmatrix}0\\2\\19\end{pmatrix}\]</span>
<p>$<span class="math inline">\(\begin{pmatrix}67\\222\\319\end{pmatrix}\equiv {\begin{pmatrix}15\\14\\7\end{pmatrix}\mod 26}\)</span></p>
<p>对应的密文便是“POH”。</p>
假设对方知道密文和密匙，首先找出密匙的逆矩阵：$
<span class="math display">\[\begin{pmatrix}8&amp;5&amp;10\\21&amp;8&amp;21\\21&amp;12&amp;8\end{pmatrix}\]</span>
<p>$</p>
将逆矩阵和密文相乘：$
<span class="math display">\[\begin{pmatrix}8&amp;5&amp;10\\21&amp;8&amp;21\\21&amp;12&amp;8\end{pmatrix}\]</span>
<p>$ <span class="math inline">\(\begin{pmatrix}8&amp;5&amp;10\\21&amp;8&amp;21\\21&amp;12&amp;8\end{pmatrix}\)</span><span class="math inline">\(\begin{pmatrix}15\\14\\7\end{pmatrix}\)</span><span class="math inline">\(\equiv \begin{pmatrix}260\\574\\539\end{pmatrix}\)</span><span class="math inline">\(\equiv {\begin{pmatrix}0\\2\\19\end{pmatrix}\mod 26}\)</span></p>
<p>便得到“ACT”。</p>
<h4 id="工具">工具</h4>
<p>https://www.quipqiup.com/</p>
<p>It can solve simple substitution ciphers.</p>
<h3 id="移位置换式密码">移位（置换）式密码</h3>
<p>移位式密码，它们字母本身不变，变的是顺序。许多移位式密码是基于几何而设计的。</p>
<h4 id="栅栏密码">栅栏密码</h4>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line">abcd</span><br><span class="line">efgh</span><br><span class="line">ijkl</span><br><span class="line">mnop</span><br><span class="line">-----</span><br><span class="line">aeimbfjncgkodhlp</span><br></pre></td></tr></table></figure>
<h3 id="古典密码学小结">古典密码学小结</h3>
<p>缺乏安全性，易被频率分析等攻击方式破解</p>
<p>CTF中常见 让考生进行唯密文攻击 的题。</p>
<h2 id="现代密码学">现代密码学</h2>
<p>而现代密码学则起源于 20 世纪中后期出现的大量相关理论，1949 年香农（C. E. Shannon）发表了题为《保密系统的通信理论》的经典论文标志着现代密码学的开始。现代密码学主要包含以下几个方面：</p>
<ul>
<li>对称加密（Symmetric Cryptography），以 DES，AES，RC4 为代表。
<ul>
<li>分组密码（Block Cipher），又称为块密码。</li>
<li>序列密码（Stream Cipher），又称为流密码。</li>
<li>……</li>
</ul></li>
<li>非对称加密（Asymmetric Cryptography），以 RSA，ElGamal，椭圆曲线加密为代表。</li>
<li>哈希函数（Hash Function），以 MD5，SHA-1，SHA-512 等为代表。</li>
<li>数字签名（Digital Signature），以 RSA 签名，ElGamal 签名，DSA 签名为代表。</li>
</ul>
<h3 id="对称密码">对称密码</h3>
<p>这类算法在加密和解密时使用相同的密钥，其安全性依靠密钥的长度和保密。</p>
<figure>
<img src="/2021/05/28/%E5%88%9D%E6%8E%A2%E5%AF%86%E7%A0%81%E5%AD%A6/Untitled%20Diagram.svg" alt="Untitled Diagram"><figcaption aria-hidden="true">Untitled Diagram</figcaption>
</figure>
<h4 id="前置知识">前置知识</h4>
<h5 id="随机数">随机数</h5>
<p>伪随机数生成器（pseudorandom number generator，PRNG），又称为确定性随机位生成器（deterministic random bit generator，DRBG），是用来生成<strong>接近于绝对随机数序列的数字序列</strong>的算法。一般来说，PRNG 会依赖于一个初始值，也称为种子，来生成对应的伪随机数序列。只要种子确定了，PRNG 所生成的随机数就是完全确定的，因此其生成的随机数序列并不是真正随机的。</p>
<p>就目前而言，PRNG 在众多应用都发挥着重要的作用，比如模拟（蒙特卡洛方法），电子竞技，密码应用。</p>
<p>随机性的严格性（这三个性质的严格性依次递增）</p>
<ul>
<li>随机性：随机数应该不存在统计学偏差，是完全杂乱的数列。</li>
<li>不可预测性：不能从过去的序列推测出下一个出现的数。</li>
<li>不可重现性：除非数列保存下来，否则不能重现相同的数列。</li>
</ul>
<table>
<thead>
<tr class="header">
<th style="text-align: right;">类别</th>
<th style="text-align: center;">随机性</th>
<th style="text-align: center;">不可预测性</th>
<th style="text-align: center;">不可重现性</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: right;">弱伪随机数</td>
<td style="text-align: center;">Y</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: right;">强伪随机数</td>
<td style="text-align: center;">Y</td>
<td style="text-align: center;">Y</td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: right;">真随机数</td>
<td style="text-align: center;">Y</td>
<td style="text-align: center;">Y</td>
<td style="text-align: center;">Y</td>
</tr>
</tbody>
</table>
<p>一般来说，密码学中使用的随机数是第二种。</p>
<p>一种常见的伪随机数生成器：</p>
<ul>
<li>线性同余发生器LCG <span class="math inline">\(X_{n+1} = (aX_n+b)\mod m\)</span></li>
</ul>
<h4 id="流密码">流密码</h4>
<p>流密码一般逐字节或者逐比特处理信息。一般来说</p>
<ul>
<li>流密码的密钥长度会与明文的长度相同。</li>
<li>流密码的密钥派生自一个较短的密钥，派生算法通常为一个伪随机数生成算法。</li>
</ul>
<p>需要注意的是，流加密目前来说都是对称加密。</p>
<p>伪随机数生成算法生成的序列的随机性越强，明文中的统计特征被覆盖的更好。</p>
<p>流密码加解密非常简单，在已知明文的情况下，可以非常容易地获取密钥流。</p>
<p>流密码的关键在于设计好的伪随机数生成器。一般来说，伪随机数生成器的基本构造模块为反馈移位寄存器。当然，也有一些特殊设计的流密码，比如 RC4。</p>
<h4 id="块密码">块密码</h4>
<p>所谓块加密就是每次加密一块明文，常见的加密算法有</p>
<ul>
<li>DES 加密 <strong><em>DES现在已经不是一种安全的加密方法，DES标准和3DES标准已逐渐被AES所取代。</em></strong>
<ul>
<li>输入 64 位。</li>
<li>输出 64 位。</li>
<li>密钥 64 位，使用 64 位密钥中的 56 位，剩余的 8 位要么丢弃，要么作为奇偶校验位。</li>
</ul></li>
<li>AES 加密
<ul>
<li>输入：128 比特。</li>
<li>输出：128 比特。</li>
<li>密钥128、192或256位</li>
</ul></li>
</ul>
<p>可以把块加密理解一种特殊的替代密码，但是其每次替代的是一大块。而正是由于一大块，明文空间巨大，而且对于不同的密钥，我们无法做一个表进行对应相应的密文，因此必须得有 <strong>复杂</strong> 的加解密算法来加解密明密文。</p>
<p>而与此同时，明文往往可能很长也可能很短，不是块长度的整数倍，因此在块加密时往往需要两个辅助</p>
<ul>
<li>padding，即 padding 到指定分组长度</li>
<li>初始化向量IV</li>
<li>分组加密模式，即明文分组加密的方式
<ul>
<li>ECB：最简单的块密码加密模式，加密前根据加密块大小（如AES为128位）分成若干块，之后将每块使用相同的密钥单独加密，解密同理。（最后一块需要padding）</li>
<li>CBC：每个明文块先与前一个密文块进行异或后，再进行加密（最后一块需要padding，在第一个块中需要使用初始化向量。）</li>
<li>PCBC</li>
<li>CFB</li>
<li>OFB</li>
<li>CTR</li>
<li>……</li>
</ul></li>
</ul>
<h4 id="小结">小结</h4>
<p>代换技术与置换技术通常结合使用。一般地，可先利用代换技术加密，再用置换技术将密文再次加密。这是现代密码学的对称加密方法的基础。</p>
<ul>
<li><p>优点</p>
<ul>
<li><p>计算量小，运算速度比非对称加密快很多</p>
<ul>
<li><p>混淆，Confusion，将密文与密钥之间的统计关系变得尽可能复杂，使得攻击者即使获取了密文的一些统计特性，也无法推测密钥。一般使用复杂的非线性变换可以得到很好的混淆效果，常见的方法如下</p>
<ul>
<li>S 盒</li>
<li>乘法</li>
</ul></li>
<li><p>扩散，Diffusion，使得明文中的每一位影响密文中的许多位。常见的方法有</p>
<ul>
<li>线性变换</li>
<li>置换</li>
<li>移位，循环移位</li>
</ul></li>
</ul></li>
</ul></li>
<li><p>缺点</p>
<ul>
<li>密钥管理
<ul>
<li>单钥密码技术要求通信双方事先交换密钥。在实际应用中，一方需要与成千上万的通信方进行交易，若采用对称密码技术，每个用户需要管理成千上万个不同对象通信的密钥</li>
<li>双方如何交换密钥。通过传统手段，还是通过因特网，都会遇到密钥传送的安全性问题。</li>
<li>在现实环境中，密钥通常会经常更换，更为极端的是，每次传送都使用不同的密钥，单钥密码技术的密钥管理和发布都是远远无法满足使用要求的。</li>
</ul></li>
</ul></li>
</ul>
<h3 id="非对称密码公钥密码">非对称密码（公钥密码）</h3>
<p>在非对称密码中，加密者与解密者所使用的密钥并不一样。一把密钥公开，一把密钥由密钥对所有者秘密保存。</p>
<p>公钥密码体制的基本原理——陷门单向函数<span class="math inline">\(f\)</span>：正向计算容易，即如果知道了加密密钥<span class="math inline">\(k_{e}\)</span>和消息<span class="math inline">\(x\)</span>，容易计算<span class="math inline">\(y=f(x;k_{e})\)</span>，不知道解密密钥<span class="math inline">\(k_{d}\)</span>时反向计算<span class="math inline">\(x=f^{-1}(y;k_{d})\)</span>不可行的（所谓计算不可行，是指计算上相当复杂，在有限的时间和成本范围内很难得到想要的结果，已无实际意义），知道解密密钥<span class="math inline">\(k_{d}\)</span>时反向计算可行。</p>
<ul>
<li>大整数质因数分解问题——RSA</li>
<li>背包问题——Merkle–Hellman背包加密</li>
<li>椭圆曲线离散对数问题——ECC，ECDH，ECDSA——（比特币）</li>
<li>循环群离散对数问题——ElGamal</li>
<li>合数模下求解平方根问题——Rabin</li>
<li>格密码（前沿）
<ul>
<li>SVP问题</li>
<li>CVP问题</li>
<li>……</li>
</ul></li>
</ul>
<figure>
<img src="/2021/05/28/%E5%88%9D%E6%8E%A2%E5%AF%86%E7%A0%81%E5%AD%A6/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86.svg" alt="非对称加密"><figcaption aria-hidden="true">非对称加密</figcaption>
</figure>
<p><strong><em>公钥密码学的出现解决了密钥分发问题，使大规模的安全通信得以实现；</em></strong></p>
<p>公钥密码学还可用于另外一些应用：数字签名、防抵赖等；</p>
<h4 id="rsa">RSA</h4>
<h5 id="公钥与私钥的产生">公钥与私钥的产生</h5>
<ol type="1">
<li>随机选取两个大质数<span class="math inline">\(p\)</span>和<span class="math inline">\(q\)</span>，其中<span class="math inline">\(p\neq q\)</span></li>
<li>计算<span class="math inline">\(N=p\times q\)</span></li>
<li>计算<span class="math inline">\(r = \varphi(N) = \varphi(p)\times\varphi(q) = (p-1)\times(q-1)\)</span>，具体参见<em>欧拉函数</em></li>
<li>选择一个小于<span class="math inline">\(r\)</span>的整数<span class="math inline">\(e\)</span>，使<span class="math inline">\(e\)</span>与<span class="math inline">\(r\)</span>互质</li>
<li>求<span class="math inline">\(d\)</span>，满足<span class="math inline">\(ed\equiv1\quad \mathrm{mod}\;r\)</span>，参见模逆元</li>
<li>销毁<span class="math inline">\(p\)</span>和<span class="math inline">\(q\)</span><strong>（为什么？）</strong></li>
<li><span class="math inline">\((N,e)\)</span>是公钥，<span class="math inline">\((N,d)\)</span>是私钥</li>
</ol>
<h6 id="pq的生成">p、q的生成</h6>
<p>常用RSA2048、RSA4096</p>
<p><strong>素性测试</strong></p>
<ul>
<li>试除法？
<ul>
<li>以RSA1024（实际中不建议使用，因为密钥长度过短）为例，p和q大约在<span class="math inline">\(2^{512}\)</span>的数量级上，太慢了！</li>
</ul></li>
<li>费马小定理（判定一个数是否为素数的<strong>必要条件</strong>）</li>
<li>Fermat素性测试：前10亿个自然数中出错的数有600个之多，第一个出错的数小得惊人，仅仅是一个三位数，<code>561</code></li>
<li>Miller-Rabin素性测试</li>
<li>………..</li>
</ul>
<p><strong>随机数</strong></p>
<ul>
<li>每次生成一个完全不一样的随机数，进行素性测试</li>
<li>成一个随机奇数之后，每次对其加2，进行素性测试</li>
<li>因此随机数生成器的安全性十分重要！
<ul>
<li>斯诺登：NSA在RSA一款加密软件的随机数算法中加入了后门</li>
</ul></li>
</ul>
<h6 id="为什么是只有两个质数多个可以吗">为什么是只有两个质数？多个可以吗？</h6>
<p>组合变多对RSA安全性反而降低了，因为分解变得容易了</p>
<h6 id="e太小">e太小</h6>
<p>例如<span class="math inline">\(e=3\)</span></p>
<p>假设用户使用的密钥 e=3。考虑到加密关系满足： <span class="math display">\[
c \equiv m3 \mod N \\
m^3 = c + k \times N \\
m = (c + k \times N)^{\frac{1}{3}}
\]</span> 攻击者可以从小到大枚举 ，依次开三次根，直到开出整数为止。</p>
<h5 id="加密与解密消息">加密与解密消息</h5>
<p><span class="math display">\[
加密\quad\quad c\equiv n^e\quad \mathrm{mod}\;N\quad\\太大怎么办？分组！n&lt;N\\
-------------\\
解密\quad\quad n\equiv c^d\quad \mathrm{mod}\;N
\]</span></p>
<h6 id="证明">证明</h6>
<p>$$ <span class="math display">\[\begin{equation}
\begin{aligned}
c^{d}&amp;\equiv n^{ed}\quad\mathrm{mod}\;N\\
n^{ed}&amp;=n^{1+k\varphi(N)}\\
&amp;=n(n^{\varphi({N})})^h\\
若n,N互质:\\
n^{ed}&amp;\equiv n(1)^h\equiv n\quad\mathrm{mod}\;N\\
若n,N不互质:\\
设\quad
n &amp;= ph\;,\;ed-1 = k(q-1)\\
有\quad
n^{ed}&amp;=(ph)^{ed}\\
&amp;\equiv ph \equiv n\quad \mathrm{mod}\;p\\
n^{ed}&amp;=n^{ed-1}n=n^{k(q-1)}n=(n^{q-1})^kn\\
&amp;\equiv 1^kn\equiv n\quad\mathrm{mod}\;q\\
\\
\implies n^{ed}\equiv&amp; n\quad\mathrm{mod}\;N

\end{aligned}
\end{equation}\]</span> $$</p>
<h5 id="使用">使用</h5>
<h6 id="机密性加解密">机密性：加解密</h6>
<p>A的公开密钥<span class="math inline">\(K_{pub}=(N,e)\)</span>，B用<span class="math inline">\(K_{pub}\)</span>对消息m加密，因为只有A拥有能解密的密钥</p>
<p>特点:</p>
<ul>
<li>B和A从来不认识，都可进行保密通讯，只要知道A的公钥</li>
<li>速度慢，不实用</li>
<li>要求对公开密钥（公钥）进行保护，防止修改和替换。<strong>（见下<u>潜在问题&gt;中间人攻击</u>）</strong></li>
</ul>
<h6 id="数字签名与身份认证">数字签名与身份认证</h6>
<p>通常我们使用公钥加密，用私钥解密。而在数字签名中，我们使用私钥加密（相当于生成签名），公钥解密（相当于验证签名）。可以这么理解：公钥是公开的，私钥是保密的，我们要用一个东西验证信息的发送者，那自然要用公开的公钥来验证；而明文只能加密，密文只能解密，所以验证时是用发送者的公钥对发来的密文进行解密。</p>
<p>加解密流程是相似的，只不过互换了e和d。</p>
<p>我们可以直接对消息进行签名（即使用私钥加密，此时加密的目的是为了签名，而不是保密），验证者用公钥正确解密消息，如果和原消息一致，则验证签名成功。但通常我们会对消息的散列值（消息摘要）签名，因为通常散列值的长度远小于消息原文，使得签名（非对称加密）的效率大大提高。注意，计算消息的散列值不是数字签名的必要步骤。</p>
<p><strong>功能：防止非法篡改、伪造，A的抵赖与否认，对A的假冒等。</strong>-&gt;因为只有A拥有A的密钥</p>
<p><strong>要求对公开密钥（公钥）进行保护，防止修改。</strong></p>
<h5 id="潜在问题">潜在问题</h5>
<h6 id="中间人攻击">中间人攻击</h6>
<p>密钥分配时，若分配公钥和密文传递遭到中间人攻击，理论上双方都不会发现被监听。</p>
<figure>
<img src="/2021/05/28/%E5%88%9D%E6%8E%A2%E5%AF%86%E7%A0%81%E5%AD%A6/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E4%B8%AD%E9%97%B4%E4%BA%BA-1622216524858.svg" alt="非对称中间人"><figcaption aria-hidden="true">非对称中间人</figcaption>
</figure>
<p><strong>解决方式</strong>：今天人们一般用可靠的第三方机构签发凭证来防止这样的攻击。详情请参阅<strong><em>CA</em></strong>及<strong><em>PKI</em></strong>。</p>
<h5 id="密钥生成">密钥生成</h5>
<blockquote>
<p>首先要使用概率算法来验证随机产生的大的整数是否质数，这样的算法比较快而且可以消除掉大多数非质数。假如有一个数通过了这个测试的话，那么要使用一个精确的测试来保证它的确是一个质数。</p>
<p>除此之外这样找到的p和q还要满足一定的要求，首先它们不能太靠近，此外p-1或q-1的因子不能太小，否则的话N也可以被很快地分解。</p>
<p>此外寻找质数的算法不能给攻击者任何信息，这些质数是怎样找到的，尤其产生随机数的软件必须非常好。要求是随机和不可预测。这两个要求并不相同。一个随机过程可能可以产生一个不相关的数的系列，但假如有人能够预测出（或部分地预测出）这个系列的话，那么它就已经不可靠了。比如有一些非常好的随机数算法，但它们都已经被发表，因此它们不能被使用，因为假如一个攻击者可以猜出<span class="math inline">\(p\)</span>和<span class="math inline">\(q\)</span>一半的位的话，那么他们就已经可以轻而易举地推算出另一半。</p>
<p>此外密钥d必须足够大，1990年有人证明假如<span class="math inline">\(p\)</span>大于<span class="math inline">\(q\)</span>而小于<span class="math inline">\(2q\)</span>（这是一个很常见的情况）而<span class="math inline">\(d&lt;\frac{1}{3}\times N^{\frac{1}{4}}\)</span>，那么从<span class="math inline">\(N\)</span>和<span class="math inline">\(e\)</span>可以很有效地推算出<span class="math inline">\(d\)</span>。此外<span class="math inline">\(e=2\)</span>永远不应该被使用。</p>
<p><strong><em>Wikipedia</em></strong></p>
</blockquote>
<h5 id="攻击-1">攻击</h5>
<ul>
<li><p>攻击RSA的一种方式的关键点在于如何分解n。若分解成功使<span class="math inline">\(n=pq\)</span>，则可以算出<span class="math inline">\(\varphi(n)＝(p-1)(q-1)\)</span>，然后由公开的e，解出秘密的d。</p></li>
<li><p>中国剩余定理</p></li>
<li><p>…………</p></li>
</ul>
<h5 id="小结-1">小结</h5>
<p>缺点</p>
<ul>
<li>在计算上比较复杂，加密速度慢
<ul>
<li>数的量级的对比</li>
<li>对称密码都是二进制布尔代数、加法，非对称密码，eg RSA都是幂运算、模运算！</li>
</ul></li>
</ul>
<h3 id="数字信封技术">数字信封技术</h3>
<p>为什么？</p>
<ul>
<li>非对称加密算法加密与解密使用不同密钥，安全性高，但是慢</li>
<li>对称加密算法速度快，但是如何安全传递密钥是个问题</li>
</ul>
<p>于是怎么办？怎么组合两种加密方法以扬长避短？</p>
<p>因此我们想到用对称加密算法来加密消息本身，而用非对称加密算法传递对称加密算法所需的密钥。一般常用的是每次会话使用不同的随机的对称加密算法密钥。</p>
<figure>
<img src="/2021/05/28/%E5%88%9D%E6%8E%A2%E5%AF%86%E7%A0%81%E5%AD%A6/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%B0%81.svg" alt="数字信封"><figcaption aria-hidden="true">数字信封</figcaption>
</figure>
<p>想要加上完整性验证，怎么办？</p>
<h4 id="数字信封数字签名">数字信封+数字签名</h4>
<p><strong><em>图例的使用很不规范，仅作示意用</em></strong></p>
<figure>
<img src="/2021/05/28/%E5%88%9D%E6%8E%A2%E5%AF%86%E7%A0%81%E5%AD%A6/diagram-1622201417795.svg" alt="diagram"><figcaption aria-hidden="true">diagram</figcaption>
</figure>
<h3 id="消息摘要算法哈希hash函数">消息摘要算法（哈希Hash函数）</h3>
<h4 id="为什么">为什么？</h4>
<ul>
<li>现实中的签名情形：
<ul>
<li>给一张纸签名、给一份合同签名、给修改的合同、给一本书签名、中缝签名</li>
</ul></li>
<li>数字签名面对的问题
<ul>
<li>变长的字符串</li>
<li>为了签名的高效完成</li>
</ul></li>
</ul>
<h4 id="hash设计基本要求">Hash设计基本要求</h4>
<ul>
<li>相同的输入产生相同的输出（散列值/指纹）</li>
<li>单向，不可逆（有效时间内不能以可负担的代价逆向计算出来）-&gt;是否和非对称加密的单向陷门函数类似？
<ul>
<li>正向计算容易、不知道解密密钥时反向计算不可行、知道解密密钥时反向计算可行：非对称有三条全部特性，Hash只符合前两条</li>
</ul></li>
<li>变长的输入，定长的输出</li>
</ul>
<h4 id="hash的应用">Hash的应用</h4>
<p>数据完整性检查</p>
<h4 id="代表性算法">代表性算法</h4>
<h5 id="md5128bit">MD5（128bit）</h5>
<ul>
<li>输入：任意长的消息，512 比特长的分组。</li>
<li>输出：128 比特的消息摘要。</li>
<li>有时候我们获得到的 md5 是 16 位的，其实那是将 32 位 md5 去掉前八位、后八位得到的。</li>
<li><strong><em>目前可以说 md5 已经基本被攻破了</em></strong>，一般的 MD5 的碰撞都可以在如下网上获取到
<ul>
<li>http://www.cmd5.com/</li>
<li>http://www.ttmd5.com/</li>
<li>http://pmd5.com/</li>
<li>https://www.win.tue.nl/hashclash/fastcoll_v1.0.0.5.exe.zip (生成指定前缀的 md5 碰撞)</li>
</ul></li>
</ul>
<h5 id="sha-1160bit">SHA-1（160bit）</h5>
<ul>
<li><p>输入：任意长的消息，分为 <strong>512 比特</strong>长的分组。首先在消息右侧补比特 1，然后再补若干个比特 0，直到消息的比特长度满足对 512 取模后余数是 448，使其与 448 模 512 同余。</p></li>
<li><p>输出：160 比特的消息摘要。</p></li>
<li><p><strong><em>就目前而言，SHA1 已经不再安全了，因为之前谷歌公布了求得两个 sha1 值一样的 pdf，具体请参考 <a href="https://shattered.io/">shattered</a> 。</em></strong></p></li>
</ul>
<h3 id="数字证书ca与pki">数字证书、CA与PKI</h3>
<p>我们知道，摘要算法用来确保数据没有被篡改，非对称加密算法可以对数据进行加解密，签名算法可以确保数据完整性和抗否认性，把这些算法集合到一起，并搞一套完善的标准，这就是数字证书。</p>
<p>因此，数字证书就是集合了多种密码学算法，用于实现数据加解密、身份认证、签名等多种功能的一种安全标准。</p>
<p>数字证书可以防止中间人攻击，因为它采用链式签名认证，即通过根证书（Root CA）去签名下一级证书，这样层层签名，直到最终的用户证书。而Root CA证书内置于操作系统中，所以，任何经过CA认证的数字证书都可以对其本身进行校验，确保证书本身不是伪造的。</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">//</span> TODO</span><br></pre></td></tr></table></figure>
<h2 id="appendix">Appendix</h2>
<h3 id="参考资料与推荐阅读">参考资料与推荐阅读</h3>
<p>[0x00] Wikipedia</p>
<p>[0x01] CTFwiki</p>
<p>[0x02] <a href="https://howiezhao.github.io/2018/08/10/classical-crypto/">古典密码学 <em>Howie's Notes</em></a></p>
<p>[0x03] 各种标准文件</p>
<p>[0x04] <a href="https://www.liaoxuefeng.com/">廖雪峰</a></p>
<p>[0xFF] <a href="https://null.sakuya.world">我的博客（没啥有营养的东西，只是参考了我之前的作业和水文，别看）</a></p>
]]></content>
      <categories>
        <category>社团</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>密码学</tag>
        <tag>讲课</tag>
      </tags>
  </entry>
</search>
